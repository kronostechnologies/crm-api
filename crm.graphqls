# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime

# Time, Format: hh:ii (23:58)
scalar Time

# Opaque cursor for page navigation on edge (base64 string)
scalar Cursor


# Enumerations

# Action activity type
enum ActionActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Action completion status
enum ActionCompletionStatus {
	FINISHED,
	PARTIAL,
	CANCELLED
}

# Action form type
enum ActionFormType {
	TODOR,
	TODOS,
	DONE
}

# Action priority
enum ActionPriority {
	HIGH,
	NORMAL,
	LOW
}

# Action re day
enum ActionReDay {
	WORKINGDAY,
	XDAY
}

# Action re mode
enum ActionReMode {
	DAY,
	NTH
}

# Action re nth day
enum ActionReNthDay {
	DAY,
	WEEKDAY,
	WEEKENDDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY,
}

# Action re nth when
enum ActionReNthWhen {
	FIRST,
	SECOND,
	THIRD,
	FOURTH,
	LAST
}

# Action re recurrence
enum ActionReRecurrence {
	DAILY,
	WEEKLY,
	MONTHLY,
	YEARLY,
	NONE,
	SINGLE
}

# Action re year month
enum ActionReYearMonth {
	JANUARY,
	FEBRUARY,
	MARCH,
	APRIL,
	MAY,
	JUNE,
	JULY,
	AUGUST,
	SEPTEMBER,
	OCTOBER,
	NOVEMBER,
	DECEMBER
}

# Action sequence type
enum ActionSequenceType {
	REGULAR,
	LATENT
}

# Action source
enum ActionSource {
	CRM,
	EXCHANGE
}

# Action state
enum ActionState {
	TODO,
	DONE
}

# Activity type
enum ActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Event type
enum EventActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Task type
enum TaskActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Available contact segments.
enum ContactSegment {
    SEGMENT_1,
    SEGMENT_2,
    SEGMENT_3,
    SEGMENT_4,
    SEGMENT_5,
    SEGMENT_6
}

# Contact type (actually Form Type in CRM)
enum ContactType {
	CUS,
	OTHER
}

# Currency
enum Currency {
	CAD,
	USD,
	EUR,
	GBP
}

# Field value type
enum FieldValueType {
	CLASS,
	ADDRESS_TYPE,
	PHONE_TYPE,
	CIVIL_STATUS,
	CONTACT_CATEGORY,
	CONTACT_DISTRIBUTION_LISTS,
	CONTACT_REFERRED_BY,
	CONTACT_HOBBY,
	CONTACT_INDUSTRY,
	CONTACT_TERRITORY,
	CONTACT_SEGMENT_1,
	CONTACT_SEGMENT_2,
	CONTACT_SEGMENT_3,
	CONTACT_SEGMENT_4,
	CONTACT_SEGMENT_5,
	CONTACT_SEGMENT_6,
	ADDRESS_COUNTRY,
	ADDRESS_CITY,
	EMAIL_TYPE
}

# Gender
enum Gender {
	MALE,
	FEMALE
}

# Insurance coverage type
enum InsuranceCoverageType {
	COVERAGE,
	RIDER
}

# Frequency
enum InterestCompoundFrequency {
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Interest Installment mode
enum InterestInstallmentMode {
	MATURITY,
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Language
enum Language {
	FRENCH,
	ENGLISH
}

# Payment mode
enum PaymentMode {
	ANNUAL,
	BIMNTHL,
	WKLY,
	MNTHLY,
	SINGLEPA,
	BIWKLY,
	DAILY,
	BIANNUAL,
	QUARTLY
}

# Plan account category
enum PlanAccountCategory {
	MUTUAL_FUND,
	SEGREGATED_FUND,
	GIC,
	SHARE,
	OTHER
}

# Sort order
enum SortOrder {
	# Ascending
	ASC,

	# Descending
	DESC
}

# Webuser Webuser Type
enum WebuserWebuserType {
	USER,
	GROUP
}

# Webuser role
enum WebuserRole {
	ADMIN,
	USER,
	KRONOS
}

# Webuser pr lang
enum WebuserPrLang {
	FR,
	EN
}

# Webuser acl all
enum WebuserAclAll {
	RWD,
	X,
	R,
	RW,
	RD
}

# Webuser active sync delete activity
enum WebuserActiveSyncDeleteActivity {
	TRANSFER_TO_DONE,
	DELETE_FROM_KRONOS,
	DO_NOTHING
}

# Webuser active sync delete contact
enum WebuserActiveSyncDeleteContact {
	REMOVE_FROM_SYNC,
	DELETE_FROM_KRONOS,
	DO_NOTHING
}


# Interfaces

# Defines a node with an ID.
interface Node {
	# Unique identifier for the node.
	id: ID!
}


# Types

# Page information answer from the server.
type PageInfo {
	# True if a next page can be fetched.
	hasNextPage: Boolean!,

	# True if a previous page can be fetched.
	hasPreviousPage: Boolean!,

	# Initial cursor from which the page starts.
	startCursor: Cursor,

	# Last cursor of the page.
	endCursor: Cursor
}

# Determines a translated field value.
type FieldValue implements Node {
	# Unique numerical identifier of the field value.
	id: ID!,

	# French field value.
	fr: String!,

	# English field value.
	en: String!,

	# DEV: Ã‰quivalent du system_name mais hard-coded pour API
	# Unique system code. Prefer using this for identification rather than id.
	code: String
}

# User entity.
type User implements Node {
	# Unique numerical identifier of the user.
	id: ID!,

	# Name of the user.
	displayName: String,

	# First name of the user.
	firstName: String,

	# Last name of the user.
	lastName: String,

	# Email of the user.
	email: String

	# TODO: todo/done Calendar ?
}

# Job entity.
type Job implements Node {
	# Unique numerical identifier of the job.
	id: ID!,

	# Name of the job.
	occupation: String,

	# Employer name.
	employer: String
}

# BaseJob mutation entity.
input BaseJob {
	# Name of the job.
	occupation: String,

	# Employer name.
	employer: String
}

# Address entity.
type Address implements Node {
	# Unique numerical identifier of the address.
	id: ID!,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address

	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}

# Address entity for inputs.
input BaseAddress {
	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: ID!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}

# Representation of a phone entity
type Phone implements Node {
	# Unique numerical identifier of the phone.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main phone number.
	main: Boolean!,

	# API DEV: vdvalue with vd_type_phone

	# Type of the phone number.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# API DEV: If longDistance is null, assume it is not the main address

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String,

	# Phone number's extension.
	extension: String
}

# Representation of a phone entity used for inputting new phone numbers.
input BasePhone {
	# True if this is considered a main phone number.
	main: Boolean!,

	# Type of the phone number.
	type: ID,

	# Actual phone number. The extension is included in it.
	number: String!,

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String,

	# Phone number's extension.
	extension: String
}

# Representation of an email entity
type Email implements Node {
	# Unique identifier of the email.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main email address.
	main: Boolean!,

	# API DEV: vd_type_email

	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

input BaseEmail {
    # True if this is considered a main email address.
    main: Boolean!,

	# Type of the email address.
	type: ID,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

interface Contact {
	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# List of websites for this contact.
	websites: [Website!]!,

	# Notes for the contact.
	notes: String

	# Actions of the contact. Can be sorted.
	actions(first: Int, after: Cursor, from: Cursor, filters: ActionListFilters!): ActionConnection!,
}

type OrganizationContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Corporation/organization name.
	corporationName: String,

	# Display name of the contact.
	displayName: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact i_contact_activity_domain
	industries: [FieldValue],

	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# List of websites for this contact.
	websites: [Website!]!,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# Notes for the contact.
	notes: String,

	# Organization abbreviation
	abbreviation: String,

	# Actions of the contact. Can be sorted.
	actions(first: Int, after: Cursor, from: Cursor, filters: ActionListFilters!): ActionConnection!
}

type IndividualContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false

	# True if the contact is a smoker. (finance only)
	smoker: Boolean!,

	# Initial date when the contact is no longer considered a smoker. (finance only)
	smokerEndDate: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL
	# API DEV: civilStatus is in vdvalues (vd_marital_status)

	# Latest civil status of the contact.
	civilStatus: CivilStatus,

	# API DEV: 1-1 relationship with job table from contacts

	# Contact's job.
	job: Job,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact hobbies
	hobbies: [FieldValue]!,

	# API DEV: Segments must be fetched with vd_seg# and vdvalues

	# Segments 1-6. Translated values. (finance only)
	seg1: FieldValue,
	seg2: FieldValue,
	seg3: FieldValue,
	seg4: FieldValue,
	seg5: FieldValue,
	seg6: FieldValue,

	# Translated territory name of the contact. (finance only)
	territory: FieldValue,

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL

	# Picture URL of the contact.
	picture: String,

	# API DEV: Parse vdvalue to return a Gender enum value

	# Gender of the contact.
	gender: Gender,

	# API DEV: Fetch with vdvalues (vd_territory)

	# Birth date of the contact.
	birthDate: Date,

	# DEV: identification_customer_no

	# Client number.
	clientNb: String,

	# Mr., Ms., Mrs., etc.
	greeting: FieldValue!,

	# List of websites for this contact.
	websites: [Website!]!,


	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# Notes for the contact.
	notes: String,

	# Calculated initials of the contact.
	initials: String,

	# Actions of the contact. Can be sorted.
	actions(first: Int, after: Cursor, from: Cursor, filters: ActionListFilters!): ActionConnection!
}

# Defines a basic individual contact.
input BaseIndividualContact {
    # First name of the contact.
    firstName: String!,

    # Last name of the contact.
    lastName: String!,

    # Middle name of the contact.
    middleName: String,

    # True if contact is a smoker.
    smoker: Boolean,

    # Date when smoker status ended.
    smokerEndDate: Date,

    # Gender.
    gender: Gender,

    # Birthdate.
    birthDate: Date,

    # Client number.
    clientNb: String
}

type CivilStatus {
    # Civil status ID.
    id: ID!,

    # Date when the civil status starts.
    startDate: Date,

    # Date when the civil status ends.
    endDate: Date,

    # Civil status value.
    status: FieldValue!
}

input BaseCivilStatus {
    # Date when the civil status starts.
    startDate: Date,

    # Date when the civil status ends.
    endDate: Date,

    # Civil status value.
    status: FieldValue!
}

# Defines a contact edge (entry), used for pagination.
type ContactEdge {
	# Actual contact.
	node: Contact,

	# Edge cursor.
	cursor: Cursor
}

# Defines a contact connection (list), used for pagination.
type ContactConnection {
	# Contacts.
	edges: [ContactEdge],

	# Page information.
	pageInfo: PageInfo
}

# Complete representation of an activity.
type Activity implements Node {
	# Unique numerical identifier of the activity.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the activity lasts all day.
	allDay: Boolean!,

	# Computed date & time when the activity starts.
	startDateTime: DateTime,

	# Computed date & time when the activity ends.
	endDateTime: DateTime,

	# Date when the activity starts.
	startDate: Date,

	# Date when the activity ends.
	endDate: Date,

	# Time when the activity starts.
	startTime: Time,

	# Time when the activity ends.
	endTime: Time,

	# Date & Time the activity was initially scheduled
	initialDate: DateTime,

	# Activity location.
	location: String,

	# Activity category.
	category: FieldValue,

	# Activity sub-category.
	subCategory: FieldValue,

	# Activity priority (1 to 5).
	priority: Int,

	# Returns true if a reminder is setup.
	hasReminder: Boolean!,

	# Reminder delay in minutes.
	reminderDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionActivity],

	# API DEV: Contained in action_notes table

	# Notes of the activity.
	notes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines an activity edge (entry), used for pagination.
type ActivityEdge {
	# Actual activity.
	node: Activity,

	# Edge cursor.
	cursor: Cursor
}

# Defines an activity connection (list), used for pagination.
type ActivityConnection {
	# Activites.
	edges: [ActivityEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines an activity exception.
type ExceptionActivity {
	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# Date & time when the activity starts.
	startDate: DateTime!,

	# Date & time when the activity ends.
	exceptionDate: DateTime!,

	# The recurrent activity is deleted for this date
	deleted: Boolean!
}

# Complete representation of an event.
type Event implements Node {
	# Unique numerical identifier of the event.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the event.
	type: EventActivityType!,

	# Subject of the event.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the event lasts all day.
	allDay: Boolean!,

	# Computed date & time when the event starts.
	startDateTime: DateTime,

	# Computed date & time when the event ends.
	endDateTime: DateTime,

	# Date when the event starts.
	startDate: Date,

	# Date when the event ends.
	endDate: Date,

	# Time when the event starts.
	startTime: Time,

	# Time when the event ends.
	endTime: Time,

	# Date & Time the event was initially scheduled
	initialDate: DateTime,

	# Event location.
	location: String,

	# Event category.
	category: FieldValue,

	# Event sub-category.
	subCategory: FieldValue,

	# Event priority (1 to 5).
	priority: Int,

	# Returns true if a reminder is setup.
	hasReminder: Boolean!,

	# Reminder delay in minutes.
	reminderDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionEvent],

	# API DEV: Contained in action_notes table

	# Notes of the event.
	notes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines an event edge (entry), used for pagination.
type EventEdge {
	# Actual event.
	node: Event,

	# Edge cursor.
	cursor: Cursor
}

# Defines an event connection (list), used for pagination.
type EventConnection {
	# Events.
	edges: [EventEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines an event exception.
type ExceptionEvent {
	# Type of the event.
	type: EventActivityType!,

	# Subject of the event.
	subject: String!,

	# Date & time when the event starts.
	startDate: DateTime!,

	# Date & time when the event ends.
	exceptionDate: DateTime!,

	# The recurrent event is deleted for this date
	deleted: Boolean!
}

# Complete representation of an task.
type Task implements Node {
	# Unique numerical identifier of the task.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the task is considered completed.
	isCompleted: Boolean!,

	# Type of the task.
	type: TaskActivityType!,

	# Subject of the event.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the task lasts all day.
	allDay: Boolean!,

	# Computed date & time when the task starts.
	startDateTime: DateTime,

	# Computed date & time when the task ends.
	endDateTime: DateTime,

	# Date when the task starts.
	startDate: Date,

	# Date when the task ends.
	endDate: Date,

	# Time when the task starts.
	startTime: Time,

	# Time when the task ends.
	endTime: Time,

	# Date & Time the task was initially scheduled
	initialDate: DateTime,

	# Task location.
	location: String,

	# Task category.
	category: FieldValue,

	# Task sub-category.
	subCategory: FieldValue,

	# Task priority (1 to 5).
	priority: Int,

	# Returns true if a reminder is setup.
	hasReminder: Boolean!,

	# Reminder delay in minutes.
	reminderDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionTask],

	# API DEV: Contained in action_notes table

	# Notes of the task.
	notes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines a task edge (entry), used for pagination.
type TaskEdge {
	# Actual task.
	node: Task,

	# Edge cursor.
	cursor: Cursor
}

# Defines an task connection (list), used for pagination.
type TaskConnection {
	# Tasks.
	edges: [TaskEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines a task exception.
type ExceptionTask {
	# Type of the task.
	type: TaskActivityType!,

	# Subject of the tasl.
	subject: String!,

	# Date & time when the task starts.
	startDate: DateTime!,

	# Date & time when the task ends.
	exceptionDate: DateTime!,

	# The recurrent task is deleted for this date
	deleted: Boolean!
}




# Defines an account plan entity.
type Plan implements Node {
	# Unique numerical identifier of the plan.
	id: ID!,

	# Plan description including type. Fake FieldValue.
	description: FieldValue!,

	# API DEV: vd_account_type_valid

	# Plan's account type, which is the main category.
	accountType: FieldValue,

	# Plan owner name.
	ownerName: String,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Current market value for the plan.
	marketValue: Float,

	# Plan accounts.
	accounts: [PlanAccount!]!
}

# Defines a plan account entity.
type PlanAccount implements Node {
	# Unique numerical identifier of the plan account.
	id: ID!,

	# Plan account category.
	category: PlanAccountCategory,

	# Manufacturer name.
	manufacturerName: String,

	# Account name or number.
	accountName: String,

	# Product name.
	productName: String,

	# Current market value for the plan.
	marketValue: Float,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Currency used for monetary amounts.
	currency: Currency,

	# Load type.
	loadType: String,

	# Fund unit quantity.
	units: Float,

	# Fund unit price
	unitPrice: Float,

	# GIC Term date
	termDate: Date,

	# GIC Certificate Nb
	certificateNb: String,

	# GIC Maturity Amount
	maturityAmount: Float,

	# GIC Maturity Date
	maturityDate: Date,

	# GIC Interest rate
	interestRate: Float,

	# GIC InitialAmount
	initialAmount: Float,

	# Initial amount date.
	initialAmountDate: Date,

	# Compound interest frequency
	compound: InterestCompoundFrequency,

	# Interest installment mode frequency
	interestInstallmentMode: InterestInstallmentMode,

	# List of interest rates
	interestRates: [InterestRate!]!
}

# Defines an interest rate.
type InterestRate implements Node {
	# Unique identifier for the interest rate.
	id: ID!,

	# Actual interest rate.
	interestRate: Float,

	# Start date from which the interest rate applies.
	dateStart: Date!,

	# End date until the interest rate applies. Inclusive.
	dateEnd: Date!
}

# Defines an insurance policy entity.
type InsurancePolicy implements Node {
	# Unique numerical identifier for the insurance policy.
	id: ID!,

	# Policy's line of business.
	lineOfBusiness: FieldValue,

	# Policy insurer name.
	ownerName: String,

	# Policy insurer name.
	carrierName: String,

	# Policy number.
	policyNb: String,

	# Policy product name.
	productName: String,

	# Policy annual premium.
	paymentAmount: Float,

	# Payment mode (frequency)
	paymentMode: PaymentMode,

	# Policy annual premium.
	annualPaymentAmount: Float,

	# Effective/Issue date
	effDate: Date,

	# Term/End date
	termDate: Date

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!,

	# Policy's insurance coverages.
	coverages: [InsuranceCoverage!]!
}

# Defines an insurance coverage entity.
type InsuranceCoverage implements Node {
	# Unique numerical identifier for the insurance coverage.
	id: ID!,

	# Coverage type.
	type: InsuranceCoverageType

	# Coverage number.
	coverageNumber: String

	# Policy product name.
	productName: String,

	# API DEV: vd_cov_product_type

	# Coverage product type.
	productType: FieldValue

	# API DEV: vd_lives_type

	# Lives types.
	livesType: FieldValue,

	# Modal premium
	modalPremiumAmount: Float,

	# current/total amount of coverage benefit
	amount: Float,

	# Effective/Issue date
	effDate: Date,

	# True if the contact is insured by this insurance coverage.
	isInsured: Boolean!,

	# List of insured clients (not contacts).
	insureds: [InsuranceInsured!]!
}

# Defines an insured client entity.
type InsuranceInsured {
	# Insured client name.
	name: String,

	# Insurance class.
	insuranceClass: String,

	# True if the insured client is a smoker.
	smoker: Boolean
}

type Website implements Node {
	# Unique numerical identifier for the website.
	id: ID!,

	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	main: Boolean!
}

input BaseWebsite {
	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	main: Boolean!
}

# Inputs
input ActivityListFilters {
	# The activities need to be contained in the specified activity types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActivityType!]!,

	# If specified, filter activity based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

input EventListFilters {
	# The events need to be contained in the specified event types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [EventActivityType!]!,

	# If specified, filter event based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

input TaskListFilters {
	# The tasks need to be contained in the specified task types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [TaskActivityType!]!,

	# If specified, filter task based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String,

	# User id.
	ownedBy: ID
}

input FieldValueFilter {
	filterLocale: Language!,

	startsWith: String
}

# Inputs
input ActionListFilters {
	# The actions need to be contained in the specified action types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActionActivityType!]!,

	# If specified, filter activity based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

# Main types
type Query {
	# Requests a single node.
	node(id: ID!): Node,

	# Current connected user.
	me: User,

	# Requests multiple, non-detailed contacts.
	contacts(first: Int, after: Cursor, from: Cursor, filters: ContactListFilters): ContactConnection!,

	# Labels for specific group.
	fieldValues(type: FieldValueType!, filters: FieldValueFilter): [FieldValue!]
}

# Mutation types
type Mutation {
    # ToDo: Remove job create, update, delete when the samples are no longer necessary.
	# Creates a new Job.
	createJob(job: BaseJob!): Job!,

	# Updates job.
	updateJob(id: ID!, job: BaseJob!): Job!,

	# Deletes job.
	deleteJob(id: ID!): Boolean!,

	# Creates a new individual contact.
	addIndividualContact(contact: BaseIndividualContact!): IndividualContact,

	# Updates an individual contact base info.
	updateIndividualContact(contactId: ID!, contact: BaseIndividualContact!): IndividualContact,

	# Deletes an individual contact.
	deleteIndividualContact(contactId: ID!): Boolean!,

	# Sets an individual contact civil status.
    addIndividualContactCivilStatus(contactId: ID!, civilStatusId: ID, since: Date): IndividualContact,

    # Deletes an individual contact civil status.
    deleteIndividualContactCivilStatus(contactId: ID!, civilStatusId: ID): IndividualContact,

    # Adds an individual contact job.
    addIndividualContactJob(contactId: ID!, job: BaseJob!): IndividualContact,

    # Deletes an individual contact job.
    deleteIndividualContactJob(contactId: ID!, jobId: ID!): IndividualContact,

    # Adds an individual contact hobby.
    addIndividualContactHobby(contactId: ID!, hobbyId: ID!): IndividualContact,

    # Deletes an individual contact hobby.
    deleteIndividualContactHobby(contactId: ID!, hobbyId: ID!): IndividualContact,

    # Sets a contact segment.
	setContactSegment(contactId: ID!, segment: ContactSegment!, segmentId: ID): Contact,

    # Sets a contact territory.
    setContactTerritory(contactId: ID!, territoryId: ID!): Contact,

    # Adds a contact category (class).
    addContactCategory(contactId: ID!, categoryId: ID!): Contact,

    # Deletes a contact category (class).
    deleteContactCategory(contactId: ID!, categoryId: ID!): Contact,

    # Adds a contact distribution list.
    addContactDistributionList(contactId: ID!, distributionListId: ID!): Contact,

    # Deletes a contact distribution list.
    deleteContactDistributionList(contactId: ID!, distributionListId: ID!): Contact,

    # Adds a contact industry.
    addContactIndustry(contactId: ID!, industryId: ID!): Contact,

    # Deletes a contact industry.
    deleteContactIndustry(contactId: ID!, industryId: ID!): Contact,

    # Adds an address for the given contact.
    addContactAddress(contactId: ID!, address: BaseAddress!): Contact,

    # Deletes an address for the given contact.
    deleteContactAddress(contactId: ID!, addressId: ID!): Contact,

    # Adds a phone number for the given contact.
    addContactPhone(contactId: ID!, phoneId: BasePhone!): Contact,

    # Deletes a phone number for the given contact.
    deleteContactPhone(contactId: ID!, phoneId: ID!): Contact,

    # Adds an email for the given contact.
    addContactEmail(contactId: ID!, email: BaseEmail!): Contact,

    # Deletes an email for the given contact.
    deleteContactEmail(contactId: ID!, emailId: ID!): Contact,

    # Adds an email for the given contact.
    addContactWebsite(contactId: ID!, website: BaseWebsite!): Contact,

    # Deletes an email for the given contact.
    deleteContactWebsite(contactId: ID!, websiteId: ID!): Contact
}

# Complete representation of an action.
type Action implements Node {
	# Unique numerical identifier of the action.
	id: ID!,

	# True if the activity is considered completed.
	private: Boolean!,

	# State of the action. TODO or DONE.
	state: ActionState!,

	# Action form type. TODOR, TODOS or DONE.
	formType: ActionFormType!,

	# Action activity type. CALL, LETTER, MEETING, VACATION, FILE, NOTE or TASK. default: CALL
	activityType: ActionActivityType!,

	# Action vd in out.
	vdInOut: Int!,

	# Action vd send via.
	vdSentVia: Int!,

	# Subject of the activity.
	subject: String,

	# Action priority. HIGH, NORMAL, LOW. Default: NORMAL
	priority: ActionPriority!,

	# Action Location.
	location: String,

	# Date when the action starts.
	dateStart: Date,

	# Time when the action starts.
	timeStart: Time,

	# Time when the action ends.
	timeEnd: Time,

	# Action vd alarm unit.
	vdAlarmUnit: Int!,

	# Date the record was created.
	dateCreated: DateTime,

	# Foreign key webuser created
	fkWebuserCreated: Int,

	# Action created by.
	createdBy: Webuser!,

	# Foreign key webuser modified
	fkWebuserModified: Int,

	# Action modified by.
	modifiedBy: Webuser,

	# Action date modified.
	dateModified: DateTime,

	# Foreign key webuser completed
	fkWebuserCompleted: Int,

	# Action completed by.
	completedBy: Webuser,

	# Action date completed.
	dateCompleted: DateTime,

	# Action source. CRM or Exchange. Default: CRM
	source: ActionSource!,

	# Action is visible. Default: Y
	visible: Boolean!,

	# Action end date
	dateEnd: Date,

	# Action initial date
	dateInitial: Date,

	# Action start day
	nbDayStart: Int!,

	# Action start day
	nbDayEnd: Int!,

	# Action alarm ?
	alarm: Boolean,

	# Action alarm delay.
	alarmDelay: Int!,

	# Notice done ?
	noticeDone: Boolean,

	# Foreign key to sequence parent.
	fkSequenceParent: Int!,

	# Action completion status.
	completionStatus: ActionCompletionStatus,

	# Notice add ?
	noticeAdd: Boolean,

	# Action re recurrence.
	reRecurrence: ActionReRecurrence!,

	# Re delete ?
	reDelete: Boolean!,

	# Action re day.
	reDay: ActionReDay,

	# Re day number.
	reDayNumber: Int!,

	# Re monday.
	reMonday: Boolean,

	# Re tuesday.
	reTuesday: Boolean,

	# Re wednesday.
	reWednesday: Boolean,

	# Re thursday.
	reThursday: Boolean,

	# Re friday.
	reFriday: Boolean,

	# Re saturday.
	reSaturday: Boolean,

	# Re sunday.
	reSunday: Boolean,

	# Re week number.
	reWeekNumber: String,

	# Re day position.
	reDayPosition: String,

	# Re day type.
	reDayType: String,

	# Action re mode.
	reMode: ActionReMode,

	# Action re nth when.
	reNthWhen: ActionReNthWhen,

	# Action re nth day.
	reNthDay: ActionReNthDay,

	# Re month day number.
	reMonthDayNumber: String,

	# Re month number.
	reMonthNumber: String,

	# Re year month day.
	reYearMonthDay: String,

	# Action re year month.
	reYearMonth: ActionReYearMonth,

	# Re duration type.
	reDurationType: String,

	# Re date start.
	reDateStart: Date,

	# Re date end.
	reDateEnd: Date,

	# Re exception date.
	reExceptionDate: Date,

	# Re occurence nb.
	reOccurenceNb: String,

	# Re fk modify.
	reFkModify: Int!,

	# Action sequence type.
	sequenceType: ActionSequenceType!,

	# External key.
	externalKey: String,

	# Vd category.
	vdCategory: Int!,

	# Vd sub category.
	vdSubCategory: Int!,

	# Delay.
	delay: Time!
}

# Defines an action edge (entry), used for pagination.
type ActionEdge {
	# Actual action.
	node: Action,

	# Edge cursor.
	cursor: Cursor
}

# Defines an action connection (list), used for pagination.
type ActionConnection {
	# Actions.
	edges: [ActionEdge],

	# Page information.
	pageInfo: PageInfo
}

# Complete representation of a webuser.
type Webuser implements Node {
	# Unique numerical identifier of the action.
	id: ID!,

	# Webuser email.
	email: String,

	# Webuser type.
	webuserType: WebuserWebuserType!,

	# Webuser role.
	role: WebuserRole,

	# Webuser in all user group ?
	allUserGroup: Boolean!,

	# Webuser screen name.
	screenName: String,

	# Webuser first name
	firstName: String,
	
	# Webuser last name.
	lastName: String,

	# Webuser initials
	initials: String,

	# Webuser passwd
	passwd: String,

	# Webuser has concurrent access
	concurrentAccess: Int!,

	# Webuser date start
	dateStart: Date,

	# Webuser date end
	dateEnd: Date,

	# Webuser is active ?
	active: Boolean,

	# Webuser is billable ?
	billable: Boolean,

	# Webuser primary language
	prLang: WebuserPrLang,

	# Webuser area code
	prAreaCode: String,

	# Webuser date created
	dateCreated: DateTime,

	# Diskspace mail.
	diskspaceMail: Int,

	#  Foreign key contact.
	fkContact: Int,

	# Access restriction ?
	accessRestriction: Boolean,

	# Greeting url
	greetingUrl: String,

	# Locale
	locale: String,

	# Timezone
	tz: String,

	# Initial conf ?
	initialConf: Boolean!,

	# Document usage mb
	documentUsageMb: Int,

	# Mail usage mb
	mailUsageMb: Int,

	# Mail quoto mb
	mailQuotaMb: Int,

	# Mail quoto getmail disabled ?
	mailQuotaGetmailDisabled: Boolean!,

	# Acl all
	aclAll: WebuserAclAll,

	# Acl all custom
	aclAllCustom: Boolean!,

	# Online
	online: Boolean,

	# Date deleted
	dateDeleted: DateTime,

	# Mobile theme
	mobileTheme: String,

	# Allow acl delegation
	allowAclDelegation: Boolean,

	# Active sync delete activity
	activeSyncDeleteActivity: WebuserActiveSyncDeleteActivity!,

	# Active sync delete contact
	activeSyncDeleteContact: WebuserActiveSyncDeleteContact!,

	# Active sync todo
	activeSyncTodo: Boolean!,

	# Active sync done
	activeSyncDone: Boolean,

	# Active sync contact gsend
	activeSyncContactGsend: Int
}
