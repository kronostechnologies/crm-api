# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime


# Enumerations
enum Gender {
	MALE,
	FEMALE
}

enum Language {
	FRENCH,
	ENGLISH
}

enum ContactType {
	INDIVIDUAL,
	ORGANIZATION
}

enum ActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}


# Interfaces
interface BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,

	# API DEV : This is not the screen_name. Use "FirstName LastName" for Individual AND "screen_name" for Organization
	# Display name of the contact.
	displayName: String

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Idividual/Organization indicator
	contactType: ContactType,

	# Contact categories
	categories: [FieldValue],

	# Picture URL location of the contact.
	picture: String

	# API DEV : IA Only. Leave blank for others
	# Contact rank
	rank: String
}

interface BaseActivity {
	# Unique numerical identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# True if the activity is assumed to be completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	startDate: DateTime,

	# Date & time when the activity ends.
	endDate: DateTime
}

type FieldValue {

	# Unique numerical identifier of the Field Value.
	id: ID,

	# French value
	fr: String!,

	# English value
	en: String!,

	# DEV: system_name lorsque pertinant
	# System Code
	code: String

}


# Types
# List pagination actually used by the server.
type PaginationAnswer {
	# Current page. Default is 1.
	page: Int,

	# Results per page. Can only be 10, 25, 50 or 100.
	perPage: Int,

	# Maximum pages that can be displayed, and also the last page.
	maxPages: Int,

	# Total number of items the server can return.
	totalItems: Int
}

# Representation of a job entity
type Job {
	# Unique identifier of the job.
	id: ID,

	# Name of the job.
	occupation: String,

	# Employer name of the job.
	employer: String
}

# Representation of an address entity
type Address {
	# Unique identifier of the address.
	id: ID,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address
	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address
	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue
	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,
}

# Representation of a phone entity
type Phone {
	# Unique identifier of the phone.
	id: ID,

	# API DEV: If main is null, assume it is not the main address
	# True if the phone number is considered to be a main one.
	main: Boolean!,

	# API DEV: vdvalue with vd_type_phone
	# Type of the phone.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# API DEV: If longDistance is null, assume it is not the main address
	# True if the number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String
}

# Representation of an email entity
type Email {
	# Unique identifier of the email.
	id: ID,

	# API DEV: If main is null, assume it is not the main address
	# True if the email address is considered to be the main one.
	main: Boolean!,

	# API DEV: vd_type_email
	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

# Representation of a contact in a list.
type ListContact implements BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,

	# Display name of the contact.
	displayName: String

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Idividual/Organization indicator
	contactType: ContactType,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too
	# Contact categories
	categories: [FieldValue],

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL
	# Picture URL of the contact.
	picture: String
}

# Represents a contact entity
type DetailedContact implements BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,

	# Display name of the contact.
	displayName: String

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String

	# Idividual/Organization indicator
	contactType: ContactType,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false
	# True if the contact is a smoker. (finance only)
	smoker: Boolean!,

	# Date when the contact was no longer considered a smoker. (finance only)
	smokerEndDate: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL
	# API DEV: civilStatus is in vdvalues (vd_marital_status)
	# Translated civil status of the contact.
	civilStatus: FieldValue,

	# API DEV: civilStatusSince is date_start of marital_status
	# Date since the current civil status is active.
	civilStatusSince: Date,

	# API DEV: 1-1 relationship with job table from contacts
	# Contact's job.
	job: Job,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too
	# Contact categories
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too
	# Contact distribution lists
	distributionLists: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too
	# Contact origins
	refferedBy: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too
	# Contact hobbies
	hobbies: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too
	# Contact i_contact_activity_domain
	industries: [FieldValue],

	# API DEV: Fetch with vdvalues (vd_territory)
	# Translated territory name of the contact. (finance only)
	territory: FieldValue,

	# API DEV: Segments must be fetched with vd_seg# and vdvalues
	# Segments 1-6. Translated values. (finance only)
	seg1: FieldValue,
	seg2: FieldValue,
	seg3: FieldValue,
	seg4: FieldValue,
	seg5: FieldValue,
	seg6: FieldValue,

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL
	# Picture URL of the contact.
	picture: String,

	# API DEV: Parse vdvalue to return a Gender enum value
	# Gender of the contact.
	gender: Gender,

	# Birth date of the contact.
	birthDate: Date,

	# DEV: identification_customer_no
	# Client #
	clientNb: String,

	# Addresses of the contact.
	adresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(pagination: PaginationParameters, filters: ActivityListFilters!, userContext: UserContext): ActivityList!,

	# Investments, or plans of the contact. (finance only)
	plans: [AccountPlan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,
}

# Representation of a list of contacts.
type ContactList {
	# List of contacts returned.
	items: [ListContact!]!,

	# Pagination currently being used by the server.
	pagination: PaginationAnswer
}

type ListActivity implements BaseActivity {
	# Unique identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)
	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');
	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	startDate: DateTime,

	# Date & time when the activity ends.
	endDate: DateTime

	# Translated location name of the activity.
	location: String,
}

# Complete representation of an activity.
type DetailedActivity implements BaseActivity {
	# Unique identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)
	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');
	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	startDate: DateTime,

	# Date & time when the activity ends.
	endDate: DateTime,

	# Date & Time the activity was initially scheduled
	initialDate: DateTime,

	# Activity location
	location: String,

	# Category
	category: String,

	# Sub-Category
	subCategory: String,

	# Activity priority 1 to 5
	priority: Int,

	# Alarm delay in minute (1440 minutes for 1 day, 60 minutes for 1 hour)
	alarmDelay: int,

	# the recurence rule for this event. The recurence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# the exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are describe in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionActivity],

	# API DEV: Contained in action_notes table
	# Description of the activity.
	description: String,

	# Contact information. Cannot be modified through a mutation of an Activity.
	contact: ListContact!

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,
}

type ExceptionActivity {

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# Date & time when the activity starts.
	startDate: DateTime!,

	# Date & time when the activity ends.
	exceptionDate: DateTime!,

	# The recurrent activity is deleted for this date
	deleted: Boolean!
}

# Defines an account plan entity. Cannot be modified.
type AccountPlan {

	# Plan description including type
	description: String,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Current market value for the plan.
	marketValue: Float,

	# DEV: vd_account_type_valid
	# Plan's account type, which is the main category.
	accountType: FieldValue,

	# Account category. This value is translated.
	accountCategory: FieldValue
}

# Defines an insurance policy entity. Cannot be modified.
type InsurancePolicy {
	# Policy's line of business.
	lineOfBusiness: FieldValue,

	# Policy insurer name.
	carrier: String,

	# Policy product name.
	product: String,

	# Policy number.
	policyNb: String,

	# Policy annual premium.
	annualPremium: Float,

	# Todo: à discuter
	# Policy benefits amount.
	benefits: Float,

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!
}

# Representation of an activity list.
type ActivityList {
	# List of activities.
	items: [ListActivity!]!,

	# Pagination currently being used by the server.
	pagination: PaginationAnswer
}


# Inputs
# List pagination parameters requested by the client.
input PaginationParameters {
	# Page requested in a list.
	page: Int,

	# ToDo: Limit perPage values?
	# Elements per page requested in a list. Supports 10, 25, 50, 100, rounded to the closest.
	perPage: Int
}

input UserContext {
	# API DEV: Use that for translating vdvalues.
	# Application language of the end user. Either en or fr.
	locale: Language
}

input ActivityListFilters {
	# The activities need to be contained in the specified activity types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActivityType!]!

	# If specified, filter activity based on completed flag.
	isCompleted: Boolean
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String
}


# Main types
type Query {
	# Requests a single, detailed contact.
	contact(id: ID!, userContext: UserContext): DetailedContact,

	# Requests multiple, non-detailed contacts.
	contacts(pagination: PaginationParameters, filters: ContactListFilters, userContext: UserContext): ContactList!,

	# Requests a single, detailed activity.
	activity(id: ID!, userContext: UserContext): DetailedActivity
}

type Mutation {
	# Writes a contact's information. Not setting the contact ID will treat it as a new contact.
	contact: DetailedContact,

	# Writes an agenda's information. Not setting the agenda ID will treat it as a new agenda.
	activity: DetailedActivity
}