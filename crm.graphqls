# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime


# Enumerations
enum Gender {
	MALE,
	FEMALE
}

enum Language {
	FRENCH,
	ENGLISH
}

enum ActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}


# Interfaces
interface BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Translated classes of the contact.
	classes: [String],

	# Picture URL location of the contact.
	picture: String
}

interface BaseActivity {
	# Unique numerical identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# True if the activity is assumed to be completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	dateExpectedStart: DateTime,

	# Date & time when the activity ends.
	dateExpectedEnd: DateTime
}


# Types
# List pagination actually used by the server.
type PaginationAnswer {
	# Current page. Default is 1.
	page: Int,

	# ToDo: Per page limits are okay?
	# Results per page. Can only be 10, 25, 50 or 100.
	perPage: Int,

	# Maximum pages that can be displayed, and also the last page.
	maxPages: Int,

	# Total number of items the server can return.
	totalItems: Int
}

# Representation of a job entity
type Job {
	# Unique identifier of the job.
	id: ID,

	# Name of the job.
	occupation: String,

	# Employer name of the job.
	employer: String
}

# Representation of an address entity
type Address {
	# Unique identifier of the address.
	id: ID,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address
	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address
	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue
	# Translated type of the address.
	type: String,

	# First line of the address.
	line1: String,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,
}

# Representation of a phone entity
type Phone {
	# Unique identifier of the phone.
	id: ID,

	# API DEV: If main is null, assume it is not the main address
	# True if the phone number is considered to be a main one.
	main: Boolean!,

	# API DEV: vdvalue with vd_type_phone
	# Translated type of the phone.
	type: String,

	# Actual phone number. The extension is included in it.
	number: String,

	# API DEV: If longDistance is null, assume it is not the main address
	# True if the number is considered long distance.
	longDistance: Boolean!,

	# Notes of the phone number.
	notes: String
}

# Representation of an email entity
type Email {
	# Unique identifier of the email.
	id: ID,

	# API DEV: If main is null, assume it is not the main address
	# True if the email address is considered to be the main one.
	main: Boolean!,

	# API DEV: vd_type_email
	# Translated type of the email address.
	type: String,

	# Actual email address.
	email: String,

	# Notes of the email address.
	notes: String
}

# Representation of a contact in a list.
type ListContact implements BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too
	# Translated classes of the contact.
	classes: [String],

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL
	# Picture URL of the contact.
	picture: String
}

# Represents a contact entity
type DetailedContact implements BaseContact {
	# Unique numerical identifier of the contact.
	id: ID,
	
	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String

	# API DEV: This is named screen_name in the database.
	# ToDo: Is this still necessary?
	# Display name of the contact.
	displayName: String

	# Decease date of the contact.
	dateDecease: Date,

	# API DEV: If smoker is null, assume false
	# True if the contact is a smoker.
	smoker: Boolean!,

	# Date when the contact was no longer considered a smoker.
	smokerDateEnd: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL
	# API DEV: civilStatus is in vdvalues (vd_marital_status)
	# Translated civil status of the contact.
	civilStatus: String,

	# API DEV: civilStatusSince is date_start of marital_status
	# Date since the current civil status is active.
	civilStatusSince: Date,

	# API DEV: 1-1 relationship with job table from contacts
	# Contact's job.
	job: Job,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too
	# Translated classes of the contact.
	classes: [String],

	# API DEV: Fetch with vdvalues (vd_territory)
	# Translated territory name of the contact.
	territory: String,

	# API DEV: Segments must be fetched with vd_seg# and vdvalues
	# Segments 1-6. Translated values.
	seg1: String,
	seg2: String,
	seg3: String,
	seg4: String,
	seg5: String,
	seg6: String,

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL
	# Picture URL of the contact.
	picture: String,

	# API DEV: Parse vdvalue to return a Gender enum value
	# Gender of the contact.
	gender: Gender,

	# Birth date of the contact.
	birthDate: Date,

	# Addresses of the contact.
	adresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(pagination: PaginationParameters, filters: ActivityListFilters!, userContext: UserContext): ActivityList!,

	# Investments, or plans of the contact.
	plans: [AccountPlan!]!,

	# Insurance policies of the contact.
	policies: [InsurancePolicy!]!
}

# Representation of a list of contacts.
type ContactList {
	# List of contacts returned.
	items: [ListContact!]!,

	# Pagination currently being used by the server.
	pagination: PaginationAnswer
}

type ListActivity implements BaseActivity {
	# Unique identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)
	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');
	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	dateExpectedStart: DateTime,

	# Date & time when the activity ends.
	dateExpectedEnd: DateTime
}

# Complete representation of an activity.
type DetailedActivity implements BaseActivity {
	# Unique identifier of the activity.
	id: ID,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)
	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');
	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	dateExpectedStart: DateTime,

	# Date & time when the activity ends.
	dateExpectedEnd: DateTime,

	# Translated location name of the activity.
	location: String,

	# API DEV: Contained in action_notes table
	# Notes of the activity.
	notes: String,

	# Contact information. Cannot be modified through a mutation of an Activity.
	contact: ListContact!
}

# Defines an account plan entity. Cannot be modified.
type AccountPlan {
	# Last updated date of the plan.
	marketValueUpdatedAt: Date,

	# Current market value for the plan.
	marketValue: Float,

	# Plan's account type, which is the main category.
	accountType: String,

	# Account category. This value is translated.
	accountCategory: String
}

# Defines an insurance policy entity. Cannot be modified.
type InsurancePolicy {
	# Policy's line of business.
	lineOfBusiness: String,

	# Policy insurer name.
	carrier: String,

	# Policy product name.
	product: String,

	# Policy number.
	policyNb: String,

	# Policy annual premium.
	annualPremium: Float,

	# Policy benefits amount.
	benefits: Float,

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!
}

# Representation of an activity list.
type ActivityList {
	# List of activities.
	items: [ListActivity!]!,

	# Pagination currently being used by the server.
	pagination: PaginationAnswer
}


# Inputs
# List pagination parameters requested by the client.
input PaginationParameters {
	# Page requested in a list.
	page: Int,

	# ToDo: Limit perPage values?
	# Elements per page requested in a list. Supports 10, 25, 50, 100, rounded to the closest.
	perPage: Int
}

input UserContext {
	# API DEV: Use that for translating vdvalues.
	# Application language of the end user. Either en or fr.
	locale: Language
}

input ActivityListFilters {
	# The activities need to be contained in the specified activity types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActivityType!]!
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String
}


# Main types
type Query {
	# Requests a single, detailed contact.
	contact(id: ID!, userContext: UserContext): DetailedContact,

	# Requests multiple, non-detailed contacts.
	contacts(pagination: PaginationParameters, filters: ContactListFilters, userContext: UserContext): ContactList!,

	# Requests a single, detailed activity.
	activity(id: ID!, userContext: UserContext): DetailedActivity
}

type Mutation {
	# Writes a contact's information. Not setting the contact ID will treat it as a new contact.
	contact: DetailedContact,

	# Writes an agenda's information. Not setting the agenda ID will treat it as a new agenda.
	activity: DetailedActivity
}