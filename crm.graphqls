# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime

# Time, Format: hh:ii (23:58)
scalar Time

# Opaque cursor for page navigation on edge (base64 string)
scalar Cursor


# Enumerations

# Event type
enum EventActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE
}

# Event or Task priority
enum CalendarPriority {
	LOW
	NORMAL
	HIGH
}

# Event state
enum CalendarState {
	TODO,
	DONE
}

# Contact type (actually Form Type in CRM)
enum ContactType {
	CLIENT,
	OTHER
}

# Currency
enum Currency {
	CAD,
	USD,
	EUR,
	GBP
}

# Field value type
enum FieldValueType {
	CLASS,
	ADDRESS_TYPE,
	PHONE_TYPE,
	MARITAL_STATUS,
	CONTACT_CATEGORY,
	CONTACT_DISTRIBUTION_LISTS,
	CONTACT_REFERRED_BY,
	CONTACT_HOBBY,
	CONTACT_INDUSTRY,
	CONTACT_TERRITORY,
	CONTACT_SEGMENT_1,
	CONTACT_SEGMENT_2,
	CONTACT_SEGMENT_3,
	CONTACT_SEGMENT_4,
	CONTACT_SEGMENT_5,
	CONTACT_SEGMENT_6,
	ADDRESS_COUNTRY,
	ADDRESS_CITY,
	EMAIL_TYPE
}

# Gender
enum Gender {
	MALE,
	FEMALE
}

# Insurance coverage type
enum InsuranceCoverageType {
	COVERAGE,
	RIDER
}

# Language
enum Language {
	FRENCH,
	ENGLISH
}

# Payment mode
enum PaymentMode {
	ANNUAL,
	BIMNTHL,
	WKLY,
	MNTHLY,
	SINGLEPA,
	BIWKLY,
	DAILY,
	BIANNUAL,
	QUARTLY
}

# Plan account category
enum PlanAccountCategory {
	MUTUAL_FUND,
	SEGREGATED_FUND,
	GIC,
	SHARE,
	OTHER
}

# Sort order
enum SortOrder {
	# Ascending
	ASC,

	# Descending
	DESC
}



# Interfaces

# Defines a node with an ID.
interface Node {
	# Unique identifier for the node.
	id: ID!
}


# Types

# Page information answer from the server.
type PageInfo {
	# True if a next page can be fetched.
	hasNextPage: Boolean!,

	# True if a previous page can be fetched.
	hasPreviousPage: Boolean!,

	# Initial cursor from which the page starts.
	startCursor: Cursor,

	# Last cursor of the page.
	endCursor: Cursor
}

# Determines a translated field value.
type FieldValue implements Node {
	# Unique numerical identifier of the field value.
	id: ID!,

	# Label of the field value in the current user language.
	label: String!,

	# French field value label.
	fr: String!,

	# English field value label.
	en: String!,

	# DEV: Équivalent du system_name mais hard-coded pour API
	# Unique system code. Prefer using this for identification rather than id.
	code: String
}

# User entity.
type User implements Node {
	# Unique numerical identifier of the user.
	id: ID!,

	# Name of the user.
	displayName: String,

	# First name of the user.
	firstName: String,

	# Last name of the user.
	lastName: String,

	# Email of the user.
	email: String,

	# Language of the user
	language: Language
}

# Occupation/ Job entity.
type Occupation implements Node {
	# Unique numerical identifier of the occupation.
	id: ID!,

	# Name of the occupation / job.
	occupation: String,

	# Employer name.
	employer: String,

	# Date the occupation started
	startDate: Date,

	# Date the occupation finished
	endDate: Date,
}


# Address entity.
type Address implements Node {
	# Unique numerical identifier of the address.
	id: ID!,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address

	# True if this is considered as a main address.
	isMain: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	isPostal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}


# Representation of a phone entity
type Phone implements Node {
	# Unique numerical identifier of the phone.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main phone number.
	isMain: Boolean!,

	# API DEV: vdvalue with vd_type_phone

	# Type of the phone number.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# Phone number's extension.
	extension: String,

	# API DEV: If longDistance is null, assume it is not the main address

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String

}

# Representation of an email entity
type Email implements Node {
	# Unique identifier of the email.
	id: ID!,

	# API DEV: If main is null, assume it is not the main email address

	# True if this is considered a main email address.
	isMain: Boolean!,

	# API DEV: vd_type_email

	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

type Website implements Node {
	# Unique numerical identifier for the website.
	id: ID!,

	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	isMain: Boolean!
}

type ContactPicture {

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL

	# Url to fetch the picture data
	url: String,

}

type MaritalStatus implements Node {
	# Civil status ID.
	id: ID!,

	# Date when the civil status starts.
	startDate: Date,

	# Date when the civil status ends.
	endDate: Date,

	# Civil status value.
	status: FieldValue!
}

type ContactSegmentation {

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue] @fieldValue(type: "CONTACT_CATEGORY"),

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue] @fieldValue(type: "CONTACT_DISTRIBUTION_LISTS"),

	# Contact hobbies.
	hobbies: [FieldValue] @fieldValue(type: "CONTACT_HOBBY"),

	# API DEV: i_contact_origin

	# Contact origins.
	referredBy: [FieldValue] @fieldValue(type: "CONTACT_REFERRED_BY"),

	# API DEV i_contact_activity_domain

	# Contact industries / domain / line of business
	industries: [FieldValue],

	# Segments 1.
	seg1: FieldValue @fieldValue(type: "CONTACT_SEGMENT_1"),

	# Segments 2.
	seg2: FieldValue @fieldValue(type: "CONTACT_SEGMENT_2"),

	# Segments 3.
	seg3: FieldValue @fieldValue(type: "CONTACT_SEGMENT_3"),

	# Segments 4.
	seg4: FieldValue @fieldValue(type: "CONTACT_SEGMENT_4"),

	# Segments 5.
	seg5: FieldValue @fieldValue(type: "CONTACT_SEGMENT_5"),

	# Segments 6.
	seg6: FieldValue @fieldValue(type: "CONTACT_SEGMENT_6"),

	# API DEV: Fetch with vdvalues (vd_territory)

	# Translated territory name of the contact.
	territory: FieldValue @fieldValue(type: "CONTACT_TERRITORY"),
}

interface Contact {

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String,

	# Picture of the contact.
	picture: ContactPicture,

	# Regroup contact segmentation informations
	segmentation: ContactSegmentation,

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# List of websites for this contact.
	websites: [Website!]!,

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact.
	plans: [Plan!]!,

	# Insurance policies of the contact.
	policies: [InsurancePolicy!]!,

	# Notes for the contact.
	notes: String,

	# Additional informational notes / peculiarity
	additionnalInformations: String,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,
}

type OrganizationContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Organization abbreviation
	abbreviation: String,

	# Corporation/organization name.
	corporationName: String,

	# Corporation/organization second line.
	corporationNameLine2: String,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String,

	# Picture of the contact.
	picture: ContactPicture,

	# Regroup contact segmentation informations
	segmentation: ContactSegmentation,

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# List of websites for this contact.
	websites: [Website!]!,

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact
	plans: [Plan!]!,

	# Insurance policies of the contact.
	policies: [InsurancePolicy!]!,

	# Notes for the contact.
	notes: String,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,
}

type IndividualContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	#Title / Prefix / Civility of the contact. FieldValue ID.
	title: FieldValue,

	# First name of the contact.
	firstName: String,

	# Initials or Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Contact maiden name
	maidenName: String,

	# Suffix. ex: jr
	suffix: String,

	# Contact rank. (iA profiles only)
	rank: String,

	# Is the contact deceased
	isDeceased: Boolean!,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false

	# True if the contact is a smoker.
	isSmoker: Boolean!,

	# Initial date when the contact is no longer considered a smoker.
	smokerEndDate: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL

	# Current marital status of the contact.
	currentMaritalStatus: MaritalStatus,

	# List of current and past marital statuses
	maritalStatuses: [MaritalStatus!]!,

	# API DEV: 1-1 relationship with job table from contacts

	# Contact's current occupation.
	currentOccupation: Occupation,

	# List of all occupations / job for the contact.
	occupations: [Occupation!]!,

	# Regroup segmentation fields
	segmentation: ContactSegmentation,

	# API DEV: Parse vdvalue to return a Gender enum value

	# Gender of the contact.
	gender: Gender,

	# Birth date of the contact.
	birthDate: Date,

	# DEV: identification_customer_no

	# Client number.
	clientNb: String,

	# Greating or salutation to use at the end of a letter
	greeting: String,

	# List of websites for this contact.
	websites: [Website!]!,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String,

	# Picture of the contact.
	picture: ContactPicture,

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Events of the contact. Can be sorted.
	events(first: Int, after: Cursor, from: Cursor, filters: EventListFilters!): EventConnection!,

	# Tasks of the contact. Can be sorted.
	tasks(first: Int, after: Cursor, from: Cursor, filters: TaskListFilters!): TaskConnection!,

	# Investments, or plans of the contact.
	plans: [Plan!]!,

	# Insurance policies of the contact.
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# Notes for the contact.
	notes: String,

	# Additional informational notes / peculiarity
	additionnalInformations: String,
}


# Defines a contact edge (entry), used for pagination.
type ContactEdge {
	# Actual contact.
	node: Contact,

	# Edge cursor.
	cursor: Cursor
}

# Defines a contact connection (list), used for pagination.
type ContactConnection {
	# Contacts.
	edges: [ContactEdge],

	# Page information.
	pageInfo: PageInfo
}

# Complete representation of an event.
type Event implements Node {
	# Unique numerical identifier of the event.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the event.
	type: EventActivityType!,

	# Subject of the event.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the event lasts all day.
	allDay: Boolean!,

	# Computed date & time when the event starts.
	startDateTime: DateTime,

	# Computed date & time when the event ends.
	endDateTime: DateTime,


	# Date the event was initially scheduled
	initialDate: Date,

	# Event location.
	location: String,

	# Event category.
	category: FieldValue,

	# Event sub-category.
	subCategory: FieldValue,

	# Event priority LOW, NORMAL or HIGH.
	priority: CalendarPriority!,

	# Returns true if a reminder is setup.
	hasReminder: Boolean!,

	# Reminder delay in minutes.
	reminderDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionEvent],

	# API DEV: Contained in action_notes table

	# Description of the event.
	description: String,

	# Internal notes on the event.
	internalNotes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines an event edge (entry), used for pagination.
type EventEdge {
	# Actual event.
	node: Event,

	# Edge cursor.
	cursor: Cursor
}

# Defines an event connection (list), used for pagination.
type EventConnection {
	# Events.
	edges: [EventEdge],

	# Page information.
	pageInfo: PageInfo
}


# Defines an event exception.
type ExceptionEvent {
	# Type of the event.
	type: EventActivityType!,

	# Subject of the event.
	subject: String!,

	# Actual Date & time when the event exception starts.
	startDateTime: DateTime!,

	# Actual Date & time when the event exception ends.
	endDateTime: DateTime!,

	# Represent the date of the exception in the recurrence. This date is the
	# same as the date found in the EXDATE of the master recurrence.
	exceptionDate: Date!,

	# The recurrent event is deleted for this date
	deleted: Boolean!
}

# Complete representation of an task.
type Task implements Node {
	# Unique numerical identifier of the task.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the task is considered completed.
	isCompleted: Boolean!,

	# Subject of the event.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# Computed date & time when the task starts.
	startDateTime: DateTime,

	# Computed date & time when the task ends.
	endDateTime: DateTime,

	# Date when the task starts.
	startDate: Date,

	# Date when the task ends.
	endDate: Date,

	# Date the task was initially scheduled
	initialDate: Date,

	# Task category.
	category: FieldValue,

	# Task sub-category.
	subCategory: FieldValue,

	# Task priority LOW, NORMAL or HIGH.
	priority: CalendarPriority!,


	# API DEV: Contained in action_notes table

	# Description of the task.
	description: String,

	# Internal notes on the task.
	internalNotes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines a task edge (entry), used for pagination.
type TaskEdge {
	# Actual task.
	node: Task,

	# Edge cursor.
	cursor: Cursor
}

# Defines an task connection (list), used for pagination.
type TaskConnection {
	# Tasks.
	edges: [TaskEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines an account plan entity.
type Plan implements Node {
	# Unique numerical identifier of the plan.
	id: ID!,

	# Plan description including type. Fake FieldValue.
	description: FieldValue!,

	# API DEV: vd_account_type_valid

	# Plan's account type, which is the main category.
	accountType: FieldValue,

	# Plan owner name.
	ownerName: String,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Current market value for the plan.
	marketValue: Float,

	# Plan accounts.
	accounts: [PlanAccount!]!
}

# Defines a plan account entity.
type PlanAccount implements Node {
	# Unique numerical identifier of the plan account.
	id: ID!,

	# Plan account category.
	category: PlanAccountCategory,

	# Manufacturer name.
	manufacturerName: String,

	# Account name or number.
	accountName: String,

	# Product name.
	productName: String,

	# Current market value for the plan.
	marketValue: Float,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Currency used for monetary amounts.
	currency: Currency,

	# Load type.
	loadType: String,

	# Fund unit quantity.
	units: Float,

	# Fund unit price
	unitPrice: Float,

	# GIC Term date
	termDate: Date,

	# GIC Certificate Nb
	certificateNb: String,

	# GIC Maturity Amount
	maturityAmount: Float,

	# GIC Maturity Date
	maturityDate: Date,

	# GIC Interest rate
	interestRate: Float,

	# GIC InitialAmount
	initialAmount: Float,

	# GIC Initial amount date.
	initialAmountDate: Date,

}

# Defines an insurance policy entity.
type InsurancePolicy implements Node {
	# Unique numerical identifier for the insurance policy.
	id: ID!,

	# Policy's line of business.
	lineOfBusiness: FieldValue,

	# Policy insurer name.
	ownerName: String,

	# Policy insurer name.
	carrierName: String,

	# Policy number.
	policyNb: String,

	# Policy product name.
	productName: String,

	# Policy annual premium.
	paymentAmount: Float,

	# Payment mode (frequency)
	paymentMode: PaymentMode,

	# Policy annual premium.
	annualPaymentAmount: Float,

	# Effective/Issue date
	effDate: Date,

	# Term/End date
	termDate: Date

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!,

	# Policy's insurance coverages.
	coverages: [InsuranceCoverage!]!
}

# Defines an insurance coverage entity.
type InsuranceCoverage implements Node {
	# Unique numerical identifier for the insurance coverage.
	id: ID!,

	# Coverage type.
	type: InsuranceCoverageType

	# Coverage number.
	coverageNumber: String

	# Policy product name.
	productName: String,

	# API DEV: vd_cov_product_type

	# Coverage product type.
	productType: FieldValue

	# API DEV: vd_lives_type

	# Lives types.
	livesType: FieldValue,

	# Modal premium
	modalPremiumAmount: Float,

	# current/total amount of coverage benefit
	amount: Float,

	# Effective/Issue date
	effDate: Date,

	# True if the contact is insured by this insurance coverage.
	isInsured: Boolean!,

	# List of insured clients (not contacts).
	insureds: [InsuranceInsured!]!
}

# Defines an insured client entity.
type InsuranceInsured {
	# Insured client name.
	name: String,

	# Insurance class.
	insuranceClass: String,

	# True if the insured client is a smoker.
	isSmoker: Boolean
}


# Inputs
input EventListFilters {
	# The events need to be contained in the specified event types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [EventActivityType!]!,

	# If specified, filter event based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

input TaskListFilters {
	# If specified, filter task based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String,

	# User id.
	ownedBy: ID
}

input FieldValueFilter {
	filterLocale: Language!,

	startsWith: String
}

# Main types
type Query {
	# Requests a single node.
	node(id: ID!): Node,

	# Current connected user.
	me: User,

	# Requests multiple, non-detailed contacts.
	contacts(first: Int, after: Cursor, from: Cursor, filters: ContactListFilters): ContactConnection!,

	# Labels for specific group.
	fieldValues(type: FieldValueType!, filters: FieldValueFilter): [FieldValue!]
}

# Mutation types
type Mutation {

	# Create an Individual contact
	createIndividualContact(input: CreateIndividualContactInput!): CreateIndividualContactPayload,

	# Update an individual contact
	updateIndividualContact(input: UpdateIndividualContactInput!) : UpdateIndividualContactPayload,

	# Create an organization Contact
	createOrganizationContact(input: CreateOrganizationContactInput!): CreateOrganizationContactPayload,

	# Update an organization contact
	updateOrganizationContact(input: UpdateOrganizationContactInput!) : UpdateOrganizationContactPayload,

	# Adds an address for the given contact.
	addToContactAddresses(input: AddToContactAddressesInput!): AddToContactAddressesPayload,

	# Link an existing address to a contact. (phase 2)
	# addExistingAddressToContactAddresses(input: LinkAddressToContactInput!): LinkAddressToContactPayload

	# Remove an adress from the given contact. The address will be deleted if not linked to another contact
	removeFromContactAddresses(input: RemoveFromContactAddressesInput!): RemoveFromContactAddressesPayload,

	# Update an existing address
	updateAddress(input: UpdateAddressInput!): UpdateAddressPayload,

	# Select the main address to use for a contact
	setContactMainAddress(input: SetContactMainAddressInput!): SetContactMainAddressPayload,

	# Select the main address to use for a contact
	setContactPostalAddress(input: SetContactPostalAddressInput!): SetContactPostalAddressPayload,

	# Adds an address for the given contact.
	addToContactPhones(input: AddToContactPhonesInput!): AddToContactPhonesPayload,

	# Remove a phone for the given contact.
	removeFromContactPhones(input: RemoveFromContactPhonesInput!): RemoveFromContactPhonesPayload,

	# TODO: updatePhone()

	# Adds an address for the given contact.
	addToContactEmails(input: AddToContactEmailsInput!): AddToContactEmailsPayload,

	# Remove a email for the given contact.
	removeFromContactEmails(input: RemoveFromContactEmailsInput!): RemoveFromContactEmailsPayload,

	# TODO: updateEmail()

	# Adds an address for the given contact.
	addToContactWebsites(input: AddToContactWebsitesInput!): AddToContactWebsitesPayload,

	# Remove a website for the given contact.
	removeFromContactWebsites(input: RemoveFromContactWebsitesInput!): RemoveFromContactWebsitesPayload,

	# TODO: updateWebsite()

	# TODO phase ultérieur : addToContactOccupations().
	# TODO phase ultérieur : removeFromContactOccupations()
	# TODO phase ultérieur : addToContactMaritalStatuses().
	# TODO phase ultérieur : removeFromContactMaritalStatuses()
	# TODO phase ultérieur : addToContactCategories()
	# TODO phase ultérieur : removeFromContactCategories()
	# TODO phase ultérieur : addToContactDistributionLists()
	# TODO phase ultérieur : removeFromContactDistributionLists()
	# TODO phase ultérieur : addToContactReferredBy()
	# TODO phase ultérieur : removeFromContactReferredBy()
	# TODO phase ultérieur : addToContactIndustries()
	# TODO phase ultérieur : removeFromContactIndustries()
	# TODO phase ultérieur : addToContactHobbies()
	# TODO phase ultérieur : removeFromContactHobbies()


	deleteContact(input: DeleteContactInput!): DeleteContactPayload,


	# TODO Event Add/Update/Delete/trf en réalisé
	# TODO Task Add/Update/Delete/trf en réalisé
}

input CreateIndividualContactInput {

	# TODO: segmenter ou non identificaiton et info additionnel. C'est recommandé de faire de petit bloc pour évolution plus facile.

	identification: CreateIndividualContactIdentificationInput,

	# Regroup additionnal fields
	additionalInfo: IndividualContactAdditionalInfoInput,

	# Regroup segmentation fields
	segmentation: ContactSegmentationInput,

	# Contact occupation(s). currentOccupation will be computed.
	occupations: [OccupationInput!],

	# Create Address for the contact
	addresses: [CreateAddressInput!],

	# Create Phone for the contact
	phones: [CreatePhoneInput!],

	# Create email for the contact
	emails: [CreateEmailInput!],

	# Create Website for the contact
	websites: [CreateWebsiteInput!],

	# Notes for the contact.
	notes: String,

	# Additional informational notes / peculiarity
	additionnalInformations: String,

}

type CreateIndividualContactPayload {
	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Data of the created Contact
	contact: IndividualContact
}

input CreateIndividualContactIdentificationInput {

	# Title / Prefix / Civility of the contact. FieldValue ID.
	titleId: ID,

	# Gender.
	gender: Gender!,

	# First name of the contact.
	firstName: String!,

	# Initials or Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String!,

	# Contact maiden name
	maidenName: String,

	# Suffix. ex: jr
	suffix: String,

	# Greating or salutation to use at the end of a letter
	greeting: String,

	# Client number.
	clientNb: String,

	# Contact rank.  (iA profiles only)
	rank: String
}

input IndividualContactAdditionalInfoInput {

	# True if contact is a smoker.
	isSmoker: Boolean,

	# Date when smoker status ended.
	smokerEndDate: Date,

	# Birthdate.
	birthDate: Date,

	# Date of death.
	dateOfDeath: Date,

}

input UpdateIndividualContactInput {

	contactId: ID!

	# Update contact identification
	identification: UpdateIndividualContactIdentificationInput,

	# Segmentation fields
	segmentation: ContactSegmentationInput,

	# Contact occupation(s). currentOccupation will be computed.
	occupations: [OccupationInput!],

	# Notes for the contact.
	notes: String,

	# Additional informational notes / peculiarity
	additionnalInformations: String,

}

type UpdateIndividualContactPayload {
	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Data of the updated Contact
	contact: IndividualContact
}

input UpdateIndividualContactIdentificationInput {
	# Title of the contact. FieldValue ID.
	titleId: ID,

	# Gender.
	gender: Gender,

	# First name of the contact.
	firstName: String,

	# Initials or Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Contact maiden name
	maidenName: String,

	# Suffix. ex: jr
	suffix: String,

	# Greating or salutation to use at the end of a letter
	greeting: String,

	# Client number.
	clientNb: String,

	# Contact rank.  (iA profiles only)
	rank: String

}

input CreateOrganizationContactInput {

	identification: CreateOrganizationContactIdentificationInput,

	# Segmentation fields
	segmentation: ContactSegmentationInput,

}

type CreateOrganizationContactPayload {
	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Data of the created Contact
	contact: OrganizationContact
}

input CreateOrganizationContactIdentificationInput {

	# Organization abbreviation
	abbreviation: String!,

	# Corporation/organization name.
	corporationName: String!,

	# Corporation/organization second line.
	corporationNameLine2: String,

	# initials of the contact.
	initials: String,

	# Client number.
	clientNb: String,
}

input UpdateOrganizationContactInput {

	# Id of the contact to update
	contactId: ID!,

	# Identification fields
	identification: UpdateOrganizationContactIdentificationInput,

	# Segmentation fields
	segmentation: ContactSegmentationInput,

}

type UpdateOrganizationContactPayload {
	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Data of the updated Contact
	contact: OrganizationContact
}

input UpdateOrganizationContactIdentificationInput {

	# Organization abbreviation
	abbreviation: String,

	# Corporation/organization name.
	corporationName: String,

	# Corporation/organization second line.
	corporationNameLine2: String,

	# initials of the contact.
	initials: String,

	# Client number.
	clientNb: String,
}

input ContactSegmentationInput {

	# Contact categories/classes.
	categoryIds: [ID!] @fieldValueId(type: "CONTACT_CATEGORY"),

	# Contact distribution lists.
	distributionListIds: [ID!] @fieldValueId(type: "CONTACT_DISTRIBUTION_LISTS"),

	# Contact origins.
	referredByIds: [ID!] @fieldValueId(type: "CONTACT_REFERRED_BY"),

	# Segments 1.
	seg1Id: ID @fieldValueId(type: "CONTACT_SEGMENT_1"),

	# Segments 2.
	seg2Id: ID @fieldValueId(type: "CONTACT_SEGMENT_2"),

	# Segments 3.
	seg3Id: ID @fieldValueId(type: "CONTACT_SEGMENT_3"),

	# Segments 4.
	seg4Id: ID @fieldValueId(type: "CONTACT_SEGMENT_4"),

	# Segments 5.
	seg5Id: ID @fieldValueId(type: "CONTACT_SEGMENT_5"),

	# Segments 6.
	seg6Id: ID @fieldValueId(type: "CONTACT_SEGMENT_6"),

	# Translated territory name of the contact.
	territoryId: ID @fieldValueId(type: "CONTACT_TERRITORY"),

}


input AddToContactAddressesInput {
	contactId: ID!,

	# True if this is considered as a main address.
	isMain: Boolean,

	# True if this is considered as a postal address.
	isPostal: Boolean,

	# Address details
	address: CreateAddressInput!
}

type AddToContactAddressesPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the address was created for
	contact: Contact,

	# Created address
	address: Address,

}

input CreateAddressInput {

	# Type of the address.
	typeId: ID! @fieldValueId(type: "ADDRESS_TYPE"),

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}

input SetContactMainAddressInput {

	# Id of the contac to update the address for.
	contactId: ID!,

	# Address id
	addressId: ID!
}

type SetContactMainAddressPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the address was updated for
	contact: Contact,
}

input SetContactPostalAddressInput {

	# Id of the contac to update the address for.
	contactId: ID!,

	# Address id
	addressId: ID!
}

type SetContactPostalAddressPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the address was updated for
	contact: Contact,
}

input UpdateAddressInput {

	# Id of the address to update
	addressId: ID!,

	# Type of the address.
	typeId: ID @fieldValueId(type: "ADDRESS_TYPE"),

	# First line of the address.
	line1: String,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String

}

type UpdateAddressPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# The updated address
	address: Address

}

input RemoveFromContactAddressesInput {

	# Id of the contact to remove address from
	contactId: ID!,

	# Id of the address to delete
	addressId: ID!,
}

type RemoveFromContactAddressesPayload {

	# Contact the address was removed from
	contact: Contact,
}


input AddToContactPhonesInput {
	contactId: ID!,

	# True if this is considered a main phone number.
	isMain: Boolean,

	# Phone details
	phone: PhoneInput!
}

type AddToContactPhonesPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the address was created for
	contact: Contact,

	# Created phone
	phone: Phone,

}

# Representation of a phone entity used for inputting new phone numbers.
input CreatePhoneInput {

	# Type of the phone number.
	typeId: ID! @fieldValueId(type: "PHONE_TYPE"),

	# Actual phone number. The extension is included in it.
	number: String!,

	# Phone number's extension.
	extension: String,

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String

}

input RemoveFromContactPhonesInput {

	# Id of the contact to remove address from
	contactId: ID!,

	# Id of the address to delete
	phoneId: ID!,
}

type RemoveFromContactPhonesPayload {

	# Contact the address was removed from
	contact: Contact,
}

input AddToContactEmailsInput {
	contactId: ID!,

	# True if this is considered a main email address.
	isMain: Boolean,

	# Email details
	email: CreateEmailInput!
}

type AddToContactEmailsPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the email address was created for
	contact: Contact,

	# Created phone
	email: Email,

}

input CreateEmailInput {

	# Type of the email address.
	typeId: ID! @fieldValueId(type: "EMAIL_TYPE"),

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

type RemoveFromContactEmailsPayload {

	# Contact the email was removed from
	contact: Contact,
}


input AddToContactWebsitesInput {
	contactId: ID!,

	# True if this is considered a main website url.
	isMain: Boolean,

	# Websitedetails
	website: CreateWebsiteInput!
}

type AddToContactWebsitesPayload {

	# Mutation ID initially provided to the input mutation, or null if not provided.
	clientMutationId: String,

	# Contact the email address was created for
	contact: Contact,

	# Created phone
	website: Website,

}

input CreateWebsiteInput {

	# Website's URL.
	url: String!,

}

type RemoveFromContactWebsitesPayload {

	# Contact the website was removed from
	contact: Contact,
}


input OccupationInput {

	# Name of the occupation / job.
	occupation: String,

	# Employer name.
	employer: String
}


input MaritalStatusInput {
	# Date when the marital status starts.
	startDate: Date,

	# Date when the marital status ends.
	endDate: Date,

	# Marital status value.
	status: FieldValue!
}

input DeleteContactInput {

	# Id of the contact to delete
	contactId: ID!,
}

type DeleteContactPayload {
}

