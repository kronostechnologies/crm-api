# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime

# Opaque cursor for page navigation on edge (base64 string)
scalar Cursor


# Enumerations

# Gender
enum Gender {
	MALE,
	FEMALE
}

# Language
enum Language {
	FRENCH,
	ENGLISH
}

# Contact type (actually Form Type in CRM)
enum ContactType {
	CUS,
	OTHER
}

# Activity type
enum ActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Sort order
enum SortOrder {
	# Ascending
	ASC,

	# Descending
	DESC
}

# Plan account category
enum PlanAccountCategory {
	MUTUAL_FUND,
	SEGREGATED_FUND,
	GIC,
	SHARE,
	OTHER
}

# Currency
enum Currency {
	CAD,
	USD,
	EUR,
	GBP
}

# Payment mode
enum PaymentMode {
	ANNUAL,
	BIMNTHL,
	WKLY,
	MNTHLY,
	SINGLEPA,
	BIWKLY,
	DAILY,
	BIANNUAL,
	QUARTLY
}

# Insurance coverage type
enum InsuranceCoverageType {
	COVERAGE,
	RIDER
}

# Field value type
enum FieldValueType {
	CLASS,
	ADDRESS_TYPE,
	PHONE_TYPE,
	CIVIL_STATUS,
	CONTACT_CATEGORY,
	CONTACT_DISTRIBUTION_LISTS,
	CONTACT_REFERRED_BY,
	CONTACT_HOBBY,
	CONTACT_INDUSTRY,
	CONTACT_TERRITORY
}

# Frequency
enum InterestCompoundFrequency {
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Interest Installment mode
enum InterestInstallmentMode {
	MATURITY,
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Interfaces

# Defines a node with an ID.
interface Node {
	# Unique identifier for the node.
	id: ID!
}


# Types

# Page information answer from the server.
type PageInfo {
	# True if a next page can be fetched.
	hasNextPage: Boolean!,

	# True if a previous page can be fetched.
	hasPreviousPage: Boolean!,

	# Initial cursor from which the page starts.
	startCursor: Cursor,

	# Last cursor of the page.
	endCursor: Cursor
}

# Determines a translated field value.
type FieldValue implements Node {
	# Unique numerical identifier of the field value.
	id: ID!,

	# French field value.
	fr: String!,

	# English field value.
	en: String!,

	# DEV: Ã‰quivalent du system_name mais hard-coded pour API
	# Unique system code. Prefer using this for identification rather than id.
	code: String
}

# User entity.
type User implements Node {
	# Unique numerical identifier of the user.
	id: ID!,

	# Name of the user.
	displayName: String,

	# First name of the user.
	firstName: String,

	# Last name of the user.
	lastName: String,

	# Email of the user.
	email: String

	# TODO: todo/done Calendar ?
}

# Job entity.
type Job implements Node {
	# Unique numerical identifier of the job.
	id: ID!,

	# Name of the job.
	occupation: String,

	# Employer name.
	employer: String
}

# Address entity.
type Address implements Node {
	# Unique numerical identifier of the address.
	id: ID!,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address

	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String
}

# Representation of a phone entity
type Phone implements Node {
	# Unique numerical identifier of the phone.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main phone number.
	main: Boolean!,

	# API DEV: vdvalue with vd_type_phone

	# Type of the phone number.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# API DEV: If longDistance is null, assume it is not the main address

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String
}

# Representation of an email entity
type Email implements Node {
	# Unique identifier of the email.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main email address.
	main: Boolean!,

	# API DEV: vd_type_email

	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

# Represents a contact entity
type Contact implements Node {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Display name of the contact.
	displayName: String,

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Determines whether or not this is an organization contact
	isOrganization: Boolean!,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false

	# True if the contact is a smoker. (finance only)
	smoker: Boolean!,

	# Initial date when the contact is no longer considered a smoker. (finance only)
	smokerEndDate: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL
	# API DEV: civilStatus is in vdvalues (vd_marital_status)

	# Translated civil status of the contact.
	civilStatus: FieldValue,

	# API DEV: civilStatusSince is date_start of marital_status

	# Date since the current civil status is active.
	civilStatusSince: Date,

	# API DEV: 1-1 relationship with job table from contacts

	# Contact's job.
	job: Job,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact hobbies
	hobbies: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact i_contact_activity_domain
	industries: [FieldValue],

	# API DEV: Fetch with vdvalues (vd_territory)

	# Translated territory name of the contact. (finance only)
	territory: FieldValue,

	# API DEV: Segments must be fetched with vd_seg# and vdvalues

	# Segments 1-6. Translated values. (finance only)
	seg1: FieldValue,
	seg2: FieldValue,
	seg3: FieldValue,
	seg4: FieldValue,
	seg5: FieldValue,
	seg6: FieldValue,

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL

	# Picture URL of the contact.
	picture: String,

	# API DEV: Parse vdvalue to return a Gender enum value

	# Gender of the contact.
	gender: Gender,

	# Birth date of the contact.
	birthDate: Date,

	# DEV: identification_customer_no

	# Client number.
	clientNb: String,

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date
}

# Defines a contact edge (entry), used for pagination.
type ContactEdge {
	# Actual contact.
	node: Contact,

	# Edge cursor.
	cursor: Cursor
}

# Defines a contact connection (list), used for pagination.
type ContactConnection {
	# Contacts.
	edges: [ContactEdge],

	# Page information.
	pageInfo: PageInfo
}

# Complete representation of an activity.
type Activity implements Node {
	# Unique numerical identifier of the activity.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the activity lasts all day.
	allDay: Boolean!,

	# Date & time when the activity starts.
	startDate: DateTime,

	# Date & time when the activity ends.
	endDate: DateTime,

	# Date & Time the activity was initially scheduled
	initialDate: DateTime,

	# Activity location.
	location: String,

	# Activity category.
	category: FieldValue,

	# Activity sub-category.
	subCategory: FieldValue,

	# Activity priority (1 to 5).
	priority: Int,

	# Alarm delay in minutes.
	alarmDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionActivity],

	# API DEV: Contained in action_notes table

	# Description of the activity.
	description: String,

	# Contact linked to this activity.
	contact: Contact!

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines an activity edge (entry), used for pagination.
type ActivityEdge {
	# Actual activity.
	node: Activity,

	# Edge cursor.
	cursor: Cursor
}

# Defines an activity connection (list), used for pagination.
type ActivityConnection {
	# Activites.
	edges: [ActivityEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines an activity exception.
type ExceptionActivity {
	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# Date & time when the activity starts.
	startDate: DateTime!,

	# Date & time when the activity ends.
	exceptionDate: DateTime!,

	# The recurrent activity is deleted for this date
	deleted: Boolean!
}

# Defines an account plan entity.
type Plan implements Node {
	# Unique numerical identifier of the plan.
	id: ID!,

	# Plan description including type. Fake FieldValue.
	description: FieldValue!,

	# API DEV: vd_account_type_valid

	# Plan's account type, which is the main category.
	accountType: FieldValue,

	# Plan owner name.
	ownerName: String,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Current market value for the plan.
	marketValue: Float,

	# Plan accounts.
	accounts: [PlanAccount!]!
}

# Defines a plan account entity.
type PlanAccount implements Node {
	# Unique numerical identifier of the plan account.
	id: ID!,

	# Plan account category.
	category: PlanAccountCategory,

	# Manufacturer name.
	manufacturerName: String,

	# Account name or number.
	accountName: String,

	# Product name.
	productName: String,

	# Current market value for the plan.
	marketValue: Float,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Currency used for monetary amounts.
	currency: Currency,

	# Load type.
	loadType: String,

	# Fund unit quantity.
	units: Float,

	# Fund unit price
	unitPrice: Float,

	# GIC Term date
	termDate: Date,

	# GIC Certificate Nb
	certificateNb: String,

	# GIC Maturity Amount
	maturityAmount: Float,

	# GIC Maturity Date
	maturityDate: Date,

	# GIC Interest rate
	interestRate: Float,

	# GIC InitialAmount
	initialAmount: Float,

	# Initial amount date.
	initialAmountDate: Date,

	# Compound interest frequency
	compound: InterestCompoundFrequency,

	# Interest installment mode frequency
	interestInstallmentMode: InterestInstallmentMode,

	# List of interest rates
	interestRates: [InterestRate!]!
}

# Defines an interest rate.
type InterestRate implements Node {
	# Unique identifier for the interest rate.
	id: ID!,

	# Actual interest rate.
	interestRate: Float,

	# Start date from which the interest rate applies.
	dateStart: Date!,

	# End date until the interest rate applies. Inclusive.
	dateEnd: Date!
}

# Defines an insurance policy entity.
type InsurancePolicy implements Node {
	# Unique numerical identifier for the insurance policy.
	id: ID!,

	# Policy's line of business.
	lineOfBusiness: FieldValue,

	# Policy insurer name.
	ownerName: String,

	# Policy insurer name.
	carrierName: String,

	# Policy number.
	policyNb: String,

	# Policy product name.
	productName: String,

	# Policy annual premium.
	paymentAmount: Float,

	# Payment mode (frequency)
	paymentMode: PaymentMode,

	# Policy annual premium.
	annualPaymentAmount: Float,

	# Effective/Issue date
	effDate: Date,

	# Term/End date
	termDate: Date

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!,

	# Policy's insurance coverages.
	coverages: [InsuranceCoverage!]!
}

# Defines an insurance coverage entity.
type InsuranceCoverage implements Node {
	# Unique numerical identifier for the insurance coverage.
	id: ID!,

	# Coverage type.
	type: InsuranceCoverageType

	# Coverage number.
	coverageNumber: String

	# Policy product name.
	productName: String,

	# API DEV: vd_cov_product_type

	# Coverage product type.
	productType: FieldValue

	# API DEV: vd_lives_type

	# Lives types.
	livesType: FieldValue,

	# Modal premium
	modalPremiumAmount: Float,

	# current/total amount of coverage benefit
	amount: Float,

	# Effective/Issue date
	effDate: Date,

	# True if the contact is insured by this insurance coverage.
	isInsured: Boolean!,

	# List of insured clients (not contacts).
	insureds: [InsuranceInsured!]!
}

# Defines an insured client entity.
type InsuranceInsured {
	# Insured client name.
	name: String,

	# Insurance class.
	insuranceClass: String,

	# True if the insured client is a smoker.
	smoker: Boolean
}

# Inputs
input ActivityListFilters {
	# The activities need to be contained in the specified activity types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActivityType!]!,

	# If specified, filter activity based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String,

	# User id.
	ownedBy: ID
}

# Main types
type Query {
	# Requests a single node.
	node(id: ID!): Node,

	# Current connected user.
	me: User,

	# Requests multiple, non-detailed contacts.
	contacts(first: Int, after: Cursor, from: Cursor, filters: ContactListFilters): ContactConnection!,

	# Labels for specific group.
	fieldValues(type: FieldValueType): [FieldValue!]
}