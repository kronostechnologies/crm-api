# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime

# Time, Format: hh:ii (23:58)
scalar Time

# Opaque cursor for page navigation on edge (base64 string)
scalar Cursor


# Enumerations

# Action activity type
enum ActionActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Action completion status
enum ActionCompletionStatus {
	FINISHED,
	PARTIAL,
	CANCELLED
}

# Action form type
enum ActionFormType {
	TODOR,
	TODOS,
	DONE
}

# Action priority
enum ActionPriority {
	PRIORITY_HIGH,
	PRIORITY_NORMAL_HIGH,
	PRIORITY_NORMAL,
	PRIORITY_NORMAL_LOW,
	PRIORITY_LOW
}

# Activity type
enum ActivityType {
	CALL,
	LETTER,
	MEETING,
	VACATION,
	FILE,
	NOTE,
	TASK
}

# Action re day
enum ActionReDay {
	WORKINGDAY,
	XDAY
}

# Action re mode
enum ActionReMode {
	DAY,
	NTH
}

# Action re nth day
enum ActionReNthDay {
	DAY,
	WEEKDAY,
	WEEKENDDAY,
	MONDAY,
	TUESDAY,
	WEDNESDAY,
	THURSDAY,
	FRIDAY,
	SATURDAY,
	SUNDAY,
}

# Action re nth when
enum ActionReNthWhen {
	FIRST,
	SECOND,
	THIRD,
	FOURTH,
	LAST
}

# Available contact segments.
enum ContactSegment {
    SEGMENT_1,
    SEGMENT_2,
    SEGMENT_3,
    SEGMENT_4,
    SEGMENT_5,
    SEGMENT_6
}

# Contact type (actually Form Type in CRM)
enum ContactType {
	CUS,
	OTHER
}

# Currency
enum Currency {
	CAD,
	USD,
	EUR,
	GBP
}

# Field value type
enum FieldValueType {
	CLASS,
	ADDRESS_TYPE,
	PHONE_TYPE,
	CIVIL_STATUS,
	CONTACT_CATEGORY,
	CONTACT_DISTRIBUTION_LISTS,
	CONTACT_REFERRED_BY,
	CONTACT_HOBBY,
	CONTACT_INDUSTRY,
	CONTACT_TERRITORY,
	CONTACT_SEGMENT_1,
	CONTACT_SEGMENT_2,
	CONTACT_SEGMENT_3,
	CONTACT_SEGMENT_4,
	CONTACT_SEGMENT_5,
	CONTACT_SEGMENT_6,
	ADDRESS_COUNTRY,
	ADDRESS_CITY,
	EMAIL_TYPE
}

# Gender
enum Gender {
	MALE,
	FEMALE
}

# Insurance coverage type
enum InsuranceCoverageType {
	COVERAGE,
	RIDER
}

# Frequency
enum InterestCompoundFrequency {
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Interest Installment mode
enum InterestInstallmentMode {
	MATURITY,
	WEEKLY,
	SEMIMONTHLY,
	MONTHLY,
	BIMONTHLY,
	QUARTERLY,
	HALF_YEARLY,
	YEARLY,
	DAILY
}

# Language
enum Language {
	FRENCH,
	ENGLISH
}

# Payment mode
enum PaymentMode {
	ANNUAL,
	BIMNTHL,
	WKLY,
	MNTHLY,
	SINGLEPA,
	BIWKLY,
	DAILY,
	BIANNUAL,
	QUARTLY
}

# Plan account category
enum PlanAccountCategory {
	MUTUAL_FUND,
	SEGREGATED_FUND,
	GIC,
	SHARE,
	OTHER
}

# Sort order
enum SortOrder {
	# Ascending
	ASC,

	# Descending
	DESC
}



# Interfaces

# Defines a node with an ID.
interface Node {
	# Unique identifier for the node.
	id: ID!
}


# Types

# Page information answer from the server.
type PageInfo {
	# True if a next page can be fetched.
	hasNextPage: Boolean!,

	# True if a previous page can be fetched.
	hasPreviousPage: Boolean!,

	# Initial cursor from which the page starts.
	startCursor: Cursor,

	# Last cursor of the page.
	endCursor: Cursor
}

# Determines a translated field value.
type FieldValue implements Node {
	# Unique numerical identifier of the field value.
	id: ID!,

	# French field value.
	fr: String!,

	# English field value.
	en: String!,

	# DEV: Ã‰quivalent du system_name mais hard-coded pour API
	# Unique system code. Prefer using this for identification rather than id.
	code: String
}

# User entity.
type User implements Node {
	# Unique numerical identifier of the user.
	id: ID!,

	# Name of the user.
	displayName: String,

	# First name of the user.
	firstName: String,

	# Last name of the user.
	lastName: String,

	# Email of the user.
	email: String

	# TODO: todo/done Calendar ?
}

# Job entity.
type Job implements Node {
	# Unique numerical identifier of the job.
	id: ID!,

	# Name of the job.
	occupation: String,

	# Employer name.
	employer: String
}

# BaseJob mutation entity.
input BaseJob {
	# Name of the job.
	occupation: String,

	# Employer name.
	employer: String
}

# Address entity.
type Address implements Node {
	# Unique numerical identifier of the address.
	id: ID!,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address

	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}

# Address entity for inputs.
input BaseAddress {
	# True if this is considered as a main address.
	main: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	postal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: ID!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}

# Representation of a phone entity
type Phone implements Node {
	# Unique numerical identifier of the phone.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main phone number.
	main: Boolean!,

	# API DEV: vdvalue with vd_type_phone

	# Type of the phone number.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# API DEV: If longDistance is null, assume it is not the main address

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String,

	# Phone number's extension.
	extension: String
}

# Representation of a phone entity used for inputting new phone numbers.
input BasePhone {
	# True if this is considered a main phone number.
	main: Boolean!,

	# Type of the phone number.
	type: ID,

	# Actual phone number. The extension is included in it.
	number: String!,

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String,

	# Phone number's extension.
	extension: String
}

# Representation of an email entity
type Email implements Node {
	# Unique identifier of the email.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main email address.
	main: Boolean!,

	# API DEV: vd_type_email

	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

input BaseEmail {
    # True if this is considered a main email address.
    main: Boolean!,

	# Type of the email address.
	type: ID,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

interface Contact {
	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# List of websites for this contact.
	websites: [Website!]!,

	# Notes for the contact.
	notes: String
}

type OrganizationContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Corporation/organization name.
	corporationName: String,

	# Display name of the contact.
	displayName: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact i_contact_activity_domain
	industries: [FieldValue],

	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# List of websites for this contact.
	websites: [Website!]!,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# Notes for the contact.
	notes: String,

	# Organization abbreviation
	abbreviation: String
}

type IndividualContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# First name of the contact.
	firstName: String,

	# Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false

	# True if the contact is a smoker. (finance only)
	smoker: Boolean!,

	# Initial date when the contact is no longer considered a smoker. (finance only)
	smokerEndDate: Date,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL
	# API DEV: civilStatus is in vdvalues (vd_marital_status)

	# Latest civil status of the contact.
	civilStatus: CivilStatus,

	# API DEV: 1-1 relationship with job table from contacts

	# Contact's job.
	job: Job,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact hobbies
	hobbies: [FieldValue]!,

	# API DEV: Segments must be fetched with vd_seg# and vdvalues

	# Segments 1-6. Translated values. (finance only)
	seg1: FieldValue,
	seg2: FieldValue,
	seg3: FieldValue,
	seg4: FieldValue,
	seg5: FieldValue,
	seg6: FieldValue,

	# Translated territory name of the contact. (finance only)
	territory: FieldValue,

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL

	# Picture URL of the contact.
	picture: String,

	# API DEV: Parse vdvalue to return a Gender enum value

	# Gender of the contact.
	gender: Gender,

	# API DEV: Fetch with vdvalues (vd_territory)

	# Birth date of the contact.
	birthDate: Date,

	# DEV: identification_customer_no

	# Client number.
	clientNb: String,

	# Mr., Ms., Mrs., etc.
	greeting: FieldValue!,

	# List of websites for this contact.
	websites: [Website!]!,


	# Contact type, form type in CRM
	contactType: ContactType!,

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue],

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact origins.
	referredBy: [FieldValue],

	# Addresses of the contact.
	addresses: [Address],

	# Phone numbers of the contact.
	phones: [Phone],

	# Emails of the contact.
	emails: [Email],

	# Activities of the contact. Can be sorted.
	activities(first: Int, after: Cursor, from: Cursor, filters: ActivityListFilters!): ActivityConnection!,

	# Investments, or plans of the contact. (finance only)
	plans: [Plan!]!,

	# Insurance policies of the contact. (finance only)
	policies: [InsurancePolicy!]!,

	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,

	# API DEV : IA Only. Leave blank for others

	# Contact rank.
	rank: String,

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue],

	# Notes for the contact.
	notes: String,

	# Calculated initials of the contact.
	initials: String
}

# Defines a basic individual contact.
input BaseIndividualContact {
    # First name of the contact.
    firstName: String!,

    # Last name of the contact.
    lastName: String!,

    # Middle name of the contact.
    middleName: String,

    # True if contact is a smoker.
    smoker: Boolean,

    # Date when smoker status ended.
    smokerEndDate: Date,

    # Gender.
    gender: Gender,

    # Birthdate.
    birthDate: Date,

    # Client number.
    clientNb: String
}

type CivilStatus {
    # Civil status ID.
    id: ID!,

    # Date when the civil status starts.
    startDate: Date,

    # Date when the civil status ends.
    endDate: Date,

    # Civil status value.
    status: FieldValue!
}

input BaseCivilStatus {
    # Date when the civil status starts.
    startDate: Date,

    # Date when the civil status ends.
    endDate: Date,

    # Civil status value.
    status: FieldValue!
}

# Defines a contact edge (entry), used for pagination.
type ContactEdge {
	# Actual contact.
	node: Contact,

	# Edge cursor.
	cursor: Cursor
}

# Defines a contact connection (list), used for pagination.
type ContactConnection {
	# Contacts.
	edges: [ContactEdge],

	# Page information.
	pageInfo: PageInfo
}

# Complete representation of an activity.
type Activity implements Node {
	# Unique numerical identifier of the activity.
	id: ID!,

	# API DEV: Assume false if null
	# API DEV: Calculated field on state (TODO = false, DONE = true)

	# True if the activity is considered completed.
	isCompleted: Boolean!,

	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# API DEV: Calculated field, ((!$row['time_start'] || $row['time_start'] == '00:00:00') && (!$row['time_end'] || $row['time_end'] == '00:00:00' || $row['time_end'] == '23:59:59') ? 'true' : 'false');

	# True if the activity lasts all day.
	allDay: Boolean!,

	# Computed date & time when the activity starts.
	startDateTime: DateTime,

	# Computed date & time when the activity ends.
	endDateTime: DateTime,

	# Date when the activity starts.
	startDate: Date,

	# Date when the activity ends.
	endDate: Date,

	# Time when the activity starts.
	startTime: Time,

	# Time when the activity ends.
	endTime: Time,

	# Date & Time the activity was initially scheduled
	initialDate: DateTime,

	# Activity location.
	location: String,

	# Activity category.
	category: FieldValue,

	# Activity sub-category.
	subCategory: FieldValue,

	# Activity priority (1 to 5).
	priority: Int,

	# Returns true if a reminder is setup.
	hasReminder: Boolean!,

	# Reminder delay in minutes.
	reminderDelay: Int,

	# The recurrence rule for this event. The recurrence is a string conform to RFC 5545 (see RRULE http://tools.ietf.org/html/rfc5545#section-3.8.5.3).
	recurrenceRule: String,

	# The exception rule for this event. The exception is a string conform to RFC 5545 (see EXDATE http://tools.ietf.org/html/rfc5545#section-3.8.5.1).
	exceptionRule: String,

	# The details of the exception that are described in the RFC5545 ExDate ($exception) string.
	# These object will never have their exception and exception_detail filled: An exception cannot have a recurrence.
	# Thus exceptions cannot have exceptions.
	exceptions: [ExceptionActivity],

	# API DEV: Contained in action_notes table

	# Notes of the activity.
	notes: String,

	# Date the record was created.
	creationDate: Date,

	# Date the record was modified.
	lastUpdateDate: Date
}

# Defines an activity edge (entry), used for pagination.
type ActivityEdge {
	# Actual activity.
	node: Activity,

	# Edge cursor.
	cursor: Cursor
}

# Defines an activity connection (list), used for pagination.
type ActivityConnection {
	# Activites.
	edges: [ActivityEdge],

	# Page information.
	pageInfo: PageInfo
}

# Defines an activity exception.
type ExceptionActivity {
	# Type of the activity.
	type: ActivityType!,

	# Subject of the activity.
	subject: String!,

	# Date & time when the activity starts.
	startDate: DateTime!,

	# Date & time when the activity ends.
	exceptionDate: DateTime!,

	# The recurrent activity is deleted for this date
	deleted: Boolean!
}

# Defines an account plan entity.
type Plan implements Node {
	# Unique numerical identifier of the plan.
	id: ID!,

	# Plan description including type. Fake FieldValue.
	description: FieldValue!,

	# API DEV: vd_account_type_valid

	# Plan's account type, which is the main category.
	accountType: FieldValue,

	# Plan owner name.
	ownerName: String,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Current market value for the plan.
	marketValue: Float,

	# Plan accounts.
	accounts: [PlanAccount!]!
}

# Defines a plan account entity.
type PlanAccount implements Node {
	# Unique numerical identifier of the plan account.
	id: ID!,

	# Plan account category.
	category: PlanAccountCategory,

	# Manufacturer name.
	manufacturerName: String,

	# Account name or number.
	accountName: String,

	# Product name.
	productName: String,

	# Current market value for the plan.
	marketValue: Float,

	# Last updated date of the plan.
	marketValueUpdateDate: Date,

	# Currency used for monetary amounts.
	currency: Currency,

	# Load type.
	loadType: String,

	# Fund unit quantity.
	units: Float,

	# Fund unit price
	unitPrice: Float,

	# GIC Term date
	termDate: Date,

	# GIC Certificate Nb
	certificateNb: String,

	# GIC Maturity Amount
	maturityAmount: Float,

	# GIC Maturity Date
	maturityDate: Date,

	# GIC Interest rate
	interestRate: Float,

	# GIC InitialAmount
	initialAmount: Float,

	# Initial amount date.
	initialAmountDate: Date,

	# Compound interest frequency
	compound: InterestCompoundFrequency,

	# Interest installment mode frequency
	interestInstallmentMode: InterestInstallmentMode,

	# List of interest rates
	interestRates: [InterestRate!]!
}

# Defines an interest rate.
type InterestRate implements Node {
	# Unique identifier for the interest rate.
	id: ID!,

	# Actual interest rate.
	interestRate: Float,

	# Start date from which the interest rate applies.
	dateStart: Date!,

	# End date until the interest rate applies. Inclusive.
	dateEnd: Date!
}

# Defines an insurance policy entity.
type InsurancePolicy implements Node {
	# Unique numerical identifier for the insurance policy.
	id: ID!,

	# Policy's line of business.
	lineOfBusiness: FieldValue,

	# Policy insurer name.
	ownerName: String,

	# Policy insurer name.
	carrierName: String,

	# Policy number.
	policyNb: String,

	# Policy product name.
	productName: String,

	# Policy annual premium.
	paymentAmount: Float,

	# Payment mode (frequency)
	paymentMode: PaymentMode,

	# Policy annual premium.
	annualPaymentAmount: Float,

	# Effective/Issue date
	effDate: Date,

	# Term/End date
	termDate: Date

	# True if the contact is the owner of this insurance policy.
	isOwner: Boolean!,

	# True if the contact is a beneficary of this insurance policy.
	isBeneficiary: Boolean!,

	# True if the contact is insured by this insurance policy.
	isInsured: Boolean!,

	# Policy's insurance coverages.
	coverages: [InsuranceCoverage!]!
}

# Defines an insurance coverage entity.
type InsuranceCoverage implements Node {
	# Unique numerical identifier for the insurance coverage.
	id: ID!,

	# Coverage type.
	type: InsuranceCoverageType

	# Coverage number.
	coverageNumber: String

	# Policy product name.
	productName: String,

	# API DEV: vd_cov_product_type

	# Coverage product type.
	productType: FieldValue

	# API DEV: vd_lives_type

	# Lives types.
	livesType: FieldValue,

	# Modal premium
	modalPremiumAmount: Float,

	# current/total amount of coverage benefit
	amount: Float,

	# Effective/Issue date
	effDate: Date,

	# True if the contact is insured by this insurance coverage.
	isInsured: Boolean!,

	# List of insured clients (not contacts).
	insureds: [InsuranceInsured!]!
}

# Defines an insured client entity.
type InsuranceInsured {
	# Insured client name.
	name: String,

	# Insurance class.
	insuranceClass: String,

	# True if the insured client is a smoker.
	smoker: Boolean
}

type Website implements Node {
	# Unique numerical identifier for the website.
	id: ID!,

	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	main: Boolean!
}

input BaseWebsite {
	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	main: Boolean!
}

# Inputs
input ActivityListFilters {
	# The activities need to be contained in the specified activity types in order to be displayed. This filter is mandatory.
	agendaTypeIn: [ActivityType!]!,

	# If specified, filter activity based on completed flag.
	isCompleted: Boolean,

	# Minimum start date.
	minStartDate: DateTime,

	# Maximum start date.
	maxStartDate: DateTime,

	# Sort order (of field sortDate).
	sortOrder: SortOrder
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String,

	# User id.
	ownedBy: ID
}

input FieldValueFilter {
	filterLocale: Language!,

	startsWith: String
}

# Main types
type Query {
	# Requests a single node.
	node(id: ID!): Node,

	# Current connected user.
	me: User,

	# Requests multiple, non-detailed contacts.
	contacts(first: Int, after: Cursor, from: Cursor, filters: ContactListFilters): ContactConnection!,

	# Labels for specific group.
	fieldValues(type: FieldValueType!, filters: FieldValueFilter): [FieldValue!]
}

# Mutation types
type Mutation {
    # ToDo: Remove job create, update, delete when the samples are no longer necessary.
	# Creates a new Job.
	createJob(job: BaseJob!): Job!,

	# Updates job.
	updateJob(id: ID!, job: BaseJob!): Job!,

	# Deletes job.
	deleteJob(id: ID!): Boolean!,

	# Creates a new individual contact.
	addIndividualContact(contact: BaseIndividualContact!): IndividualContact,

	# Updates an individual contact base info.
	updateIndividualContact(contactId: ID!, contact: BaseIndividualContact!): IndividualContact,

	# Deletes an individual contact.
	deleteIndividualContact(contactId: ID!): Boolean!,

	# Sets an individual contact civil status.
    addIndividualContactCivilStatus(contactId: ID!, civilStatusId: ID, since: Date): IndividualContact,

    # Deletes an individual contact civil status.
    deleteIndividualContactCivilStatus(contactId: ID!, civilStatusId: ID): IndividualContact,

    # Adds an individual contact job.
    addIndividualContactJob(contactId: ID!, job: BaseJob!): IndividualContact,

    # Deletes an individual contact job.
    deleteIndividualContactJob(contactId: ID!, jobId: ID!): IndividualContact,

    # Adds an individual contact hobby.
    addIndividualContactHobby(contactId: ID!, hobbyId: ID!): IndividualContact,

    # Deletes an individual contact hobby.
    deleteIndividualContactHobby(contactId: ID!, hobbyId: ID!): IndividualContact,

    # Sets a contact segment.
	setContactSegment(contactId: ID!, segment: ContactSegment!, segmentId: ID): Contact,

    # Sets a contact territory.
    setContactTerritory(contactId: ID!, territoryId: ID!): Contact,

    # Adds a contact category (class).
    addContactCategory(contactId: ID!, categoryId: ID!): Contact,

    # Deletes a contact category (class).
    deleteContactCategory(contactId: ID!, categoryId: ID!): Contact,

    # Adds a contact distribution list.
    addContactDistributionList(contactId: ID!, distributionListId: ID!): Contact,

    # Deletes a contact distribution list.
    deleteContactDistributionList(contactId: ID!, distributionListId: ID!): Contact,

    # Adds a contact industry.
    addContactIndustry(contactId: ID!, industryId: ID!): Contact,

    # Deletes a contact industry.
    deleteContactIndustry(contactId: ID!, industryId: ID!): Contact,

    # Adds an address for the given contact.
    addContactAddress(contactId: ID!, address: BaseAddress!): Contact,

    # Deletes an address for the given contact.
    deleteContactAddress(contactId: ID!, addressId: ID!): Contact,

    # Adds a phone number for the given contact.
    addContactPhone(contactId: ID!, phoneId: BasePhone!): Contact,

    # Deletes a phone number for the given contact.
    deleteContactPhone(contactId: ID!, phoneId: ID!): Contact,

    # Adds an email for the given contact.
    addContactEmail(contactId: ID!, email: BaseEmail!): Contact,

    # Deletes an email for the given contact.
    deleteContactEmail(contactId: ID!, emailId: ID!): Contact,

    # Adds an email for the given contact.
    addContactWebsite(contactId: ID!, website: BaseWebsite!): Contact,

    # Deletes an email for the given contact.
    deleteContactWebsite(contactId: ID!, websiteId: ID!): Contact
}
