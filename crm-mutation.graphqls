schema {
    query: Query
    mutation: Mutation
}

type Query {
}



type Mutation {

    # Create an Individual contact
    createIndividualContact(input: CreateIndividualContactInput!): CreateIndividualContactPayload,

    # Update an individual contact
    updateIndividualContact(input: UpdateIndividualContactInput!) : UpdateIndividualContactPayload,

    # Create an organization Contact
    createOrganizationContact(input: CreateOrganizationContactInput!): CreateOrganizationContactPayload,


    # TODO
    #updateOrganizationContact(input: UpdateOrganizationContactInput!) : UpdateOrganizationContactPayload,

    # Adds an address for the given contact.
    addContactAddress(input: AddContactAddressInput!): AddContactAddressPayload,

    # Remove an adress from the given contact. The address will be deleted if not linked to another contact
    # TODO: devrait- l'appeler removeContactAddress. Elle pourrait ne pas être supprimé si lié à d'autre contact.
    deleteContactAddress(input: DeleteContactAddressInput!): DeleteContactAddressPayload,

    # Link an existing address to a contact. (phase 2)
    # linkAddressToContact(input: LinkAddressToContactInput!): LinkAddressToContactPayload

    # Delete an address for all contact. (TODO phase 2?)
    #deleteAddress(input: DeleteAddressInput): DeleteAddressPayload


    # Phone

    # Email

    # Website

    # Segmentation

    # Job

    #####

    # TODO Event Add/Update/Delete/trf en réalisé
    # TODO Task Add/Update/Delete/trf en réalisé
}

input CreateIndividualContactInput {

    # TODO: segmenter ou non identificaiton et info additionnel. C'est recommandé de faire de petit bloc pour évolution plus facile.

    identification: IndividualContactIdentificationInput,

    additionalInfo: IndividualContactAdditionalInfoInput,

    #segmentation: ContactSegmentationInput,

}

type CreateIndividualContactPayload {
    # Mutation ID initially provided to the input mutation, or null if not provided.
    clientMutationId: String,

    # Data of the created Contact
    contact: IndividualContact
}

input CreateOrganizationContactInput {

    identification: OrganizationContactIdentificationInput,

    #segmentation: ContactSegmentationInput,

}

type CreateOrganizationContactPayload {
    # Mutation ID initially provided to the input mutation, or null if not provided.
    clientMutationId: String,

    # Data of the created Contact
    contact: OrganizationContact
}

input IndividualContactIdentificationInput {


    # Title of the contact. FieldValue ID.
    title: ID,

    # Gender. // TODO: Should it be required. It is in contact form.
    gender: Gender,

    # First name of the contact.
    firstName: String!,

    # initials of the contact.
    initials: String,

    # Last name of the contact.
    lastName: String!,

    # Middle name of the contact.  TODO: trouver ça devait être quel champ ?
    middleName: String,

    # Contact maiden name
    maidenName: String,

    # Suffix. ex: jr // TODO: is suffx middleName ?
    suffix: String,

    # Contact greating
    greating: String,

    # Client number.
    clientNb: String,

    # Contact rank.
    rank: String
}

input IndividualAdditionalInfoInput {

    # True if contact is a smoker.
    smoker: Boolean,

    # Date when smoker status ended.
    smokerEndDate: Date,

    # Birthdate.
    birthDate: Date,

    # Date of death.
    dateOfDeath: Date,

}

input OrganizationContactIdentificationInput {

    # Organization abbreviation
    abbreviation: String,

    # Corporation/organization name.
    corporationName: String,

    # Corporation/organization second line.
    corporationNameSecondLine: String,

    # initials of the contact.
    initials: String,
}

#input ContactSegmentationInput {
#}


input IndividualContactPatchInput {
    # Title of the contact. FieldValue ID.
    title: ID,

    # Gender.
    gender: Gender,

    # First name of the contact.
    firstName: String,

    # initials of the contact.
    initials: String,

    # Last name of the contact.
    lastName: String,

    # Middle name of the contact.  TODO: trouver ça devait être quel champ ?
    middleName: String,

    # Contact maiden name
    maidenName: String,

    # Suffix. ex: jr // TODO: is suffx middleName ?
    suffix: String,

    # Contact greating
    greating: String,

    # Client number.
    clientNb: String,

    # Contact rank.
    rank: String

}


input AddContactAddressInput {
    contactId: ID!,

    # True if this is considered as a main address.
    main: Boolean,

    # True if this is considered as a postal address.
    postal: Boolean,

    # Address details
    address: CreateAddressInput!
}

input CreateAddressInput {
    # Translated type of the address.
    type: ID!,

    # First line of the address.
    line1: String!,

    # Second line of the address.
    line2: String,

    # State or province of the address.
    stateProvince: String,

    # Country of the address.
    country: String,

    # Postal/zip code of the address.
    postalCode: String,

    # Date which the address became active.
    dateSince: Date,

    # City of the address.
    city: String
}

type AddContactAddressPayload {

    # Mutation ID initially provided to the input mutation, or null if not provided.
    clientMutationId: String,

    # Contact the address was created for
    contact: Contact,

    # Created address
    address: Address,

}

input DeleteContactAddressInput {

    # Id of the contact to remove address from
    contactId: ID!,

    # Id of the address to delete
    addressId: ID!,
}

type DeleteContactAddressPayload {

    # Contact the address was removed from
    contact: Contact,
}

