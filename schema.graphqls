schema {
	query: Query
}

type Query {
	# Requests a single node.
	node(id: ID!): Node,

	# Current connected user.
	me: User,

	# Requests multiple, non-detailed contacts.
	contacts(first: Int, after: Cursor, from: Cursor, filters: ContactListFilters): ContactConnection!,

	# Labels for specific group.
	fieldValues(type: FieldValueType!, filters: FieldValueFilter): [FieldValue!]
}

# Scalar types

# Date with no time, Format: YYYY-mm-dd  (2017-12-30)
scalar Date

# Date with time, Format: YYYY-mm-dd hh:ii:ss (2017-12-30 23:58:59)
scalar DateTime

# Time, Format: hh:ii (23:58)
scalar Time

# Opaque cursor for page navigation on edge (base64 string)
scalar Cursor


# Enumerations

# Contact type (actually Form Type in CRM)
enum ContactType {
	CLIENT,
	OTHER
}

# Field value type
enum FieldValueType {
	ADDRESS_CITY,
	ADDRESS_COUNTRY,
	ADDRESS_TYPE,
	CONTACT_TITLE,
	CONTACT_CATEGORY,
	CONTACT_DISTRIBUTION_LISTS,
	CONTACT_REFERRED_BY,
	CONTACT_HOBBY,
	CONTACT_INDUSTRY,
	CONTACT_TERRITORY,
	CONTACT_SEGMENT_1,
	CONTACT_SEGMENT_2,
	CONTACT_SEGMENT_3,
	CONTACT_SEGMENT_4,
	CONTACT_SEGMENT_5,
	CONTACT_SEGMENT_6,
	EMAIL_TYPE,
	MARITAL_STATUS,
	PHONE_TYPE
}

# Gender
enum Gender {
	MALE,
	FEMALE
}

# Language
enum Language {
	FRENCH,
	ENGLISH
}

# Sort order
enum SortOrder {
	# Ascending
	ASC,

	# Descending
	DESC
}

# Defines a node with an ID.
interface Node {
	# Unique identifier for the node.
	id: ID!
}

# Page information answer from the server.
type PageInfo {
	# True if a next page can be fetched.
	hasNextPage: Boolean!,

	# True if a previous page can be fetched.
	hasPreviousPage: Boolean!,

	# Initial cursor from which the page starts.
	startCursor: Cursor,

	# Last cursor of the page.
	endCursor: Cursor
}

# Determines a translated field value.
type FieldValue implements Node {
	# Unique numerical identifier of the field value.
	id: ID!,

	# Label of the field value in the current user language.
	label: String!,

	# French field value label.
	fr: String!,

	# English field value label.
	en: String!,

	# DEV: Équivalent du system_name mais hard-coded pour API
	# Unique system code. Prefer using this for identification rather than id.
	code: String
}

type ContactStatus {
	# Date the record was modified
	creationDate: Date,

	# Date the record was modified
	lastUpdateDate: Date,
}

# User entity.
type User implements Node {
	# Unique numerical identifier of the user.
	id: ID!,

	# Name of the user.
	displayName: String!,

	# First name of the user.
	firstName: String,

	# Last name of the user.
	lastName: String,

	# Email of the user.
	email: String,

	# Language of the user
	language: Language
}

# Occupation/ Job entity.
type Occupation implements Node {
	# Unique numerical identifier of the occupation.
	id: ID!,

	# Name of the occupation / job.
	occupation: String,

	# Employer name.
	employer: String,

	# Date the occupation started
	startDate: Date,

	# Date the occupation finished
	endDate: Date,
}


# Address entity.
type Address implements Node {
	# Unique numerical identifier of the address.
	id: ID!,

	# API DEV: i_contact_address contains main and postal fields
	# API DEV: If main is null, assume it is not the main address

	# True if this is considered as a main address.
	isMain: Boolean!,

	# API DEV: If postal is null, assume it is not a postal address

	# True if this is considered as a postal address.
	isPostal: Boolean!,

	# API DEV: Is a vdvalue

	# Translated type of the address.
	type: FieldValue!,

	# First line of the address.
	line1: String!,

	# Second line of the address.
	line2: String,

	# State or province of the address.
	stateProvince: String,

	# Country of the address.
	country: String,

	# Postal/zip code of the address.
	postalCode: String,

	# Date which the address became active.
	dateSince: Date,

	# City of the address.
	city: String
}


# Representation of a phone entity
type Phone implements Node {
	# Unique numerical identifier of the phone.
	id: ID!,

	# API DEV: If main is null, assume it is not the main address

	# True if this is considered a main phone number.
	isMain: Boolean!,

	# API DEV: vdvalue with vd_type_phone

	# Type of the phone number.
	type: FieldValue!,

	# Actual phone number. The extension is included in it.
	number: String!,

	# Phone number's extension.
	extension: String,

	# API DEV: If longDistance is null, assume it is not the main address

	# True if the phone number number is considered long distance.
	longDistance: Boolean,

	# Notes of the phone number.
	notes: String

}

# Representation of an email entity
type Email implements Node {
	# Unique identifier of the email.
	id: ID!,

	# API DEV: If main is null, assume it is not the main email address

	# True if this is considered a main email address.
	isMain: Boolean!,

	# API DEV: vd_type_email

	# Type of the email address.
	type: FieldValue!,

	# Actual email address.
	email: String!,

	# Notes of the email address.
	notes: String
}

type Website implements Node {
	# Unique numerical identifier for the website.
	id: ID!,

	# Website's URL.
	url: String!,

	# True if the website is the main one specified.
	isMain: Boolean!
}

type ContactPicture {

	# API DEV: Through fk_document_picture, it should be possible to fetch a public URL

	# Url to fetch the picture data
	url: String,

}

type MaritalStatus implements Node {
	# Marital status ID.
	id: ID!,

	# Date when the marital status starts.
	startDate: Date,

	# Date when the marital status ends.
	endDate: Date,

	# Marital status value.
	status: FieldValue! @fieldValue(name: "MARITAL_STATUS")
}

type ContactSegmentation {

	# API DEV: Fetch with i_contact_class, it uses vdvalues too

	# Contact categories/classes.
	categories: [FieldValue] @fieldValue(type: "CONTACT_CATEGORY"),

	# API DEV: Fetch with i_contact_gsend, it uses vdvalues too

	# Contact distribution lists
	distributionLists: [FieldValue] @fieldValue(type: "CONTACT_DISTRIBUTION_LISTS"),

	# Contact hobbies.
	hobbies: [FieldValue] @fieldValue(type: "CONTACT_HOBBY"),

	# API DEV: i_contact_origin

	# Contact origins.
	referredBy: [FieldValue] @fieldValue(type: "CONTACT_REFERRED_BY"),

	# API DEV i_contact_activity_domain

	# Contact industries / domain / line of business
	industries: [FieldValue],

	# Segments 1.
	seg1: FieldValue @fieldValue(type: "CONTACT_SEGMENT_1"),

	# Segments 2.
	seg2: FieldValue @fieldValue(type: "CONTACT_SEGMENT_2"),

	# Segments 3.
	seg3: FieldValue @fieldValue(type: "CONTACT_SEGMENT_3"),

	# Segments 4.
	seg4: FieldValue @fieldValue(type: "CONTACT_SEGMENT_4"),

	# Segments 5.
	seg5: FieldValue @fieldValue(type: "CONTACT_SEGMENT_5"),

	# Segments 6.
	seg6: FieldValue @fieldValue(type: "CONTACT_SEGMENT_6"),

	# API DEV: Fetch with vdvalues (vd_territory)

	# Translated territory name of the contact.
	territory: FieldValue @fieldValue(type: "CONTACT_TERRITORY"),
}

type ContactNotes {
	# Notes for the contact.
	notes: String,

	# Additional informational notes / peculiarity
	additionalInformations: String,
}

interface Contact {

	# Unique identifier
	id: ID!,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String!,

	# Picture of the contact.
	picture: ContactPicture,

	# Regroup contact segmentation informations
	segmentation: ContactSegmentation!,

	# Addresses of the contact.
	addresses: [Address!]!,

	# Phone numbers of the contact.
	phones: [Phone!]!,

	# Emails of the contact.
	emails: [Email!]!,

	# List of websites for this contact.
	websites: [Website!]!,

	# Notes and Additional informations notes for the contact.
	notes: ContactNotes!,

	# Status informations like creationDate
	status: ContactStatus!,
}

union ContactUnion = IndividualContact | OrganizationContact

type OrganizationContactIdentification {

	# Organization abbreviation
	abbreviation: String,

	# Corporation/organization name.
	corporationName: String,

	# Corporation/organization second line.
	corporationNameLine2: String,

	# initials of the contact.
	initials: String,

	# Client number.
	clientNb: String,
}

type OrganizationContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String!,

	# Picture of the contact.
	picture: ContactPicture,

	# Regroup contact segmentation informations
	segmentation: ContactSegmentation!,

	# Addresses of the contact.
	addresses: [Address!]!,

	# Phone numbers of the contact.
	phones: [Phone!]!,

	# Emails of the contact.
	emails: [Email!]!,

	# List of websites for this contact.
	websites: [Website!]!,

	# Notes and Additional informations notes for the contact.
	notes: ContactNotes!,

	# Status informations like creationDate
	status: ContactStatus!,
}

type IndividualContactIdentification {

	#Title / Prefix / Civility of the contact.
	title: FieldValue @fieldValue(name: "CONTACT_TITLE"),

	# Gender of the contact.
	gender: Gender,

	# First name of the contact.
	firstName: String,

	# Initials or Middle name of the contact.
	middleName: String,

	# Last name of the contact.
	lastName: String,

	# Contact maiden name
	maidenName: String,

	# Suffix. ex: jr
	suffix: String,

	# Greating or salutation to use at the end of a letter
	greeting: String,

	# Contact rank. (iA profiles only)
	rank: String,

	# DEV: identification_customer_no

	# Client number.
	clientNb: String,
}

type IndividualContactAdditionalInformation {

	# Is the contact deceased
	isDeceased: Boolean!,

	# Decease date of the contact.
	deceaseDate: Date,

	# API DEV: If smoker is null, assume false

	# True if the contact is a smoker.
	isSmoker: Boolean!,

	# Initial date when the contact is no longer considered a smoker.
	smokerEndDate: Date,

	# Birth date of the contact.
	birthDate: Date,
}

type IndividualContact implements Node, Contact {
	# Unique numerical identifier of the contact.
	id: ID!,

	# Contact identification
	identification: IndividualContactIdentification!,

	# Contact additional informations
	additionalInformation: IndividualContactAdditionalInformation!,

	# API DEV: In marital_status table, must do a TOP 1 query to fetch it, and it can be NULL

	# Current marital status of the contact.
	currentMaritalStatus: MaritalStatus,

	# List of current and past marital statuses
	# maritalStatuses: [MaritalStatus!]!, # TODO Phase ultérieur

	# API DEV: 1-1 relationship with job table from contacts

	# Contact's current occupation.
	currentOccupation: Occupation,

	# List of all occupations / job for the contact.
	# occupations: [Occupation!]!, # TODO Phase ultérieur

	# Regroup segmentation fields
	segmentation: ContactSegmentation!,

	# Contact type, form type in CRM
	contactType: ContactType!,

	# Display name of the contact.
	displayName: String!,

	# Picture of the contact.
	picture: ContactPicture,

	# Addresses of the contact.
	addresses: [Address!]!,

	# Phone numbers of the contact.
	phones: [Phone!]!,

	# Emails of the contact.
	emails: [Email!]!,

	# List of websites for this contact.
	websites: [Website!]!,

	# Notes and Additional informations notes for the contact.
	notes: ContactNotes!,

	# Status informations like creationDate
	status: ContactStatus!,
}


# Defines a contact edge (entry), used for pagination.
type ContactEdge {
	# Actual contact.
	node: Contact,

	# Edge cursor.
	cursor: Cursor
}

# Defines a contact connection (list), used for pagination.
type ContactConnection {
	# Contacts.
	edges: [ContactEdge],

	# Page information.
	pageInfo: PageInfo
}

input FieldValueFilter {
	filterLocale: Language!,

	startsWith: String
}

# Filters input of the contacts list.
input ContactListFilters {
	# If the combined values of firstName, middleName, and lastName contains the requested string, the filter will pass. Not setting the filter will ignore it.
	nameContains: String,

	# If the combined values of firstName, middleName, and lastName starts with the requested string, the filter will pass. Not setting the filter will ignore it.
	nameStartsWith: String,

	# User id.
	ownedBy: ID
}
